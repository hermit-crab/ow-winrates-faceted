<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Overwatch 2 Winrates & Pickrates – Faceted</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<script src="https://cdn.plot.ly/plotly-3.1.0.min.js"></script>
<script src="https://momentjs.com/downloads/moment.min.js"></script>
<!-- basic analytics, just for me to know if page has any visitors and I need to maintain it -->
<script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
<style>

body {
    font-family: sans-serif;
    background: #fafafa;
    margin: 20px;
}
#main {
    display: flex;
    flex-direction: column;
    align-items: center;
}
#main > * {
    /* prevent flexbox centering overflow issue */
    margin: auto;
}

.title {
    font-size: 20px;
    text-transform: uppercase;
    text-shadow: 1px 1px 0px #0002;
    display: flex;
    align-items: center;
    font-weight: bold;
    color: #393939;
}
.title svg {
    height: 25px;
    width: 25px;
    min-width: 25px;
    min-height: 25px;
    margin-right: 10px;
}

.conf {
    margin: 10px auto !important;
    font-size: 90%;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: baseline;
}
.conf-block {
    display: inline-block;
    padding: 0 6px;
    text-wrap: nowrap;
    border-left: 1px solid rgba(0, 0, 0, 0.271);
}
.conf-block:first-child {
    padding-left: 0;
    border-left: none;
}

.info {
    font-size: 80%;
    opacity: 40%;
    margin-bottom: 10px !important;
}
.info a {
    color: black;
    text-decoration: dotted;
}
.info a:hover {
    text-decoration: underline;
}
#infoBtn {
    background: none;
    border: none;
    padding: 0;
    font: inherit;
    cursor: pointer;
}
#infoBtn:hover {
    text-decoration: underline dotted;
}

.info-popup {
    display: none;
    position: fixed;
    top: 20px;
    z-index: 500;
    background-color: white;
    font-size: 90%;
    padding: 20px;
    box-shadow: 6px 6px #0004, 0 0 0 1px #0001;
}
.info-popup.shown {
    display: block;
}
.info-popup ul {
    margin: 0;
    padding-left: 20px;
    max-width: 600px;
}
#colorTips {
    font-weight: bold;
}

.plots-title {
    display: flex;
    flex-wrap: nowrap;
    font-weight: bold;
    color: #5c5c5c;
    letter-spacing: 1px;
    font-size: 60%;
    gap: 10px;
    cursor: pointer;
    user-select: none;
}
.plots-title > div {
    text-align: center;
    text-transform: uppercase;
}
.plots-title.pc > div {
    width: 300px;
}
.plots-title.pc > div:first-child {
    width: 80px;
    visibility: hidden;
}

.plots-title.pc > div:after {
    content: " ▼";
    visibility: hidden;
    opacity: 80%;
}
.plots-title.pc > div.active:after {
    content: " ▲";
}
.plots-title.pc > div.active:after, .plots-title.pc > div.active-inv:after {
    visibility: visible;
}
.plots-title.pc > div:hover:after {
    visibility: visible;
}

.plots-title.mobile {
    display: none;
    align-items: center;
    gap: 5px;
    justify-content: center;
    font-size: 80%;
    user-select: none;
    z-index: 200;
    width: 100%;
    padding: 5px 0;
    background-color: #fafafa;
    position: sticky;
    top: 0;
}
.plots-title.mobile div {
    border: 1px solid rgb(138, 138, 138);
    border-radius: 5px;
    padding: 1px 4px;
    opacity: 50%;
}

#plots {
    margin-bottom: 200px;
    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
}

.entry {
    padding-bottom: 3px;
    margin-top: 3px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.271);
    height: 100px;
    display: flex;
    position: relative;
    column-gap: 10px;
}
.entry.hidden {
    display: none;
}
.entry .hero-name {
    position: absolute;
    top: 0px;
    left: 0px;
    font-size: 80%;
    color: #0000;
}
.entry img {
    height: 80px;
    width: 80px;
    display: block;
    border-radius: 50%;
    align-self: center;
}
.entry .plot {
    height: 100px;
    width: 300px;
}
svg.main-svg, svg.main-svg * {
    /* allow xtick tooltipx overflow */
    overflow: visible;
}

/* for mobile */
@media screen and (max-width: 680px) {
    .conf {justify-content: left;}
    .entry img {height: 60px; width: 60px;}
    .plots-title.pc {display: none;}
    .plots-title.mobile {display: flex;}
    .mobile-show-wr .plot-pr {display: none;}
    .mobile-show-pr .plot-pr {display: block;}
    .mobile-show-wr .plot-wr {display: block;}
    .mobile-show-pr .plot-wr {display: none;}
    .mobile-show-pr .title-pr {opacity: 100% !important;}
    .mobile-show-wr .title-wr {opacity: 100% !important;}
}

</style>
</head>
<body>

<div class="info-popup">
    <ul>
        <li>Line colors: <span id="colorTips"></span>.</li>
        <li>Starting "<b>All</b>" values represent Competitive total values across all tiers.</li>
        <li><b>Dashed</b> lines represens "expected" value. For winrate it's 50%. For pickrate it's the value that would result if every hero in the role was equally desirable.</li>
        <li><b>Double click</b> any plot to zoom in/out (toggle own relative scale).</li>
        <li><b>Hover</b> (or click on mobile) on any plot to see exact values and legend at near position.</li>
    </ul>
</div>

<div id="main" class="mobile-show-wr">

<div class="title">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" aria-labelledby="blz-icon-title-overwatch-2-dark" viewBox="0 0 48 48" part="icon"><title id="blz-icon-title-overwatch-2-dark">Overwatch 2</title><path fill="#ED6516" d="M13.9 13.901a14.284 14.284 0 0 1 20.2 0l4.043-4.042a20 20 0 0 0-28.286 0z"></path><path fill="#333E48" d="m39.312 11.135-4.063 4.062a14.29 14.29 0 0 1 .995 16.159L28.891 24l-4.006-9.413h-.02V27.31l7.938 7.938a14.29 14.29 0 0 1-17.606 0l7.939-7.938V14.636l-4.027 9.365-7.355 7.355a14.29 14.29 0 0 1 .997-16.159l-4.063-4.062a20.001 20.001 0 1 0 30.624 0"></path></svg>
    Overwatch 2 Winrates & Pickrates – Faceted
</div>

<div class="conf">
    <div class="conf-block">
        Facet
        <select id="facet">
            <option value="region" selected>Region</option>
            <option value="input">Platform</option>
        </select>
    </div>
    <div class="conf-block">
        Select
        <select id="filterRole">
            <option value="all" selected>All Roles</option>
            <option value="support">Support</option>
            <option value="tank">Tank</option>
            <option value="damage">Damage</option>
        </select>
        <select id="filterRegion">
            <option value="Americas" selected>Americas</option>
            <option value="Asia">Asia</option>
            <option value="Europe">Europe</option>
        </select>
        <select id="filterPlatform">
            <option value="PC" selected>KB&M</option>
            <option value="Console">Console</option>
        </select>
    </div>
    <div class="conf-block">
        Sort by
        <select id="sortingMode">
            <option value="wr-delta">Winrate B / M Diff.</option>
            <option value="pr-delta">Pickrate B / M Diff.</option>
            <option value="wr-all" selected>Total Winrate</option>
            <option value="pr-all">Total Pickrate</option>
            <option value="name">Name</option>
        </select>
        in facet
        <select id="sortingRegion">
            <option value="Americas" selected>Americas</option>
            <option value="Asia">Asia</option>
            <option value="Europe">Europe</option>
        </select>
        <select id="sortingPlatform">
            <option value="PC" selected>KB&M</option>
            <option value="Console">Console</option>
        </select>
        <label><input type="checkbox" id="sortingReverse" checked></input>Reversed</label>
    </div>
</div>

<div class="info">
    dataset refreshed: <span id="datasetTs"></span> ┊
    <button id="infoBtn">legend and tips</button> ┊
    <a href="https://overwatch.blizzard.com/en-us/rates/">official source</a> ┊
    <a href="https://docs.google.com/forms/d/e/1FAIpQLSd8aEzuAdIPjHKv_0VND6HbKdywIi7SWBeIFV2k1t_3bvHaIw/viewform?usp=dialog">report issue</a>
</div>

<div class="plots-title pc">
    <div>Name</div>
    <div class="title-wr">Winrate</div>
    <div class="title-pr">Pickrate</div>
</div>
<div class="plots-title mobile">
    <div class="title-wr">Winrate</div>
    <div class="title-pr">Pickrate</div>
</div>

<div id="plots"></div>

</div>

<script>

const TIERS = ["Bronze", "Silver", "Gold", "Platinum", "Diamond", "Master", "Grandmaster"];
const TIER_COLORS = ["#cd7850", "#c4c6c8", "#d8a43d", "#98d8b9", "#5f9ff0", "#8ae960", "#8d71fe"];
const REGIONS = ["Americas", "Asia", "Europe"];
const REGION_COLORS = ["#f14141", "#ffac00", "#3c90ff"];
const PLATFORMS = ["PC", "Console"];
// const PLATFORM_COLORS = ["#16a616", "#8d71fe"]
const PLATFORM_COLORS = ["black", "gray"];
const LOCAL_JSONP_SRC = "winrate-data.js";
const EXTERNAL_JSONP_SRC = "https://hermit-crab.neocities.org/winrate-data.js?nocache=" + parseInt(Date.now()/1000/60/60);
const ALL_TIER_IDX = -.5;

const tiersInfo = Object.fromEntries(TIERS.map((name, idx) => [name, {
    idx: idx,
    color: TIER_COLORS[idx],
    shorthand: name !== "Grandmaster" ? name[0] : "GM+",
}]));
const xticklabels = TIERS.map(n => `<span style="color: ${tiersInfo[n].color}; font-weight: bold">${tiersInfo[n].shorthand}</span>`);
const plotsElem = document.getElementById("plots");
const tsElem = document.getElementById("datasetTs");
const confElems = {
    facet: document.getElementById("facet"),
    filterRole: document.getElementById("filterRole"),
    filterPlatform: document.getElementById("filterPlatform"),
    filterRegion: document.getElementById("filterRegion"),
    sortingMode: document.getElementById("sortingMode"),
    sortingRegion: document.getElementById("sortingRegion"),
    sortingPlatform: document.getElementById("sortingPlatform"),
    sortingReverse: document.getElementById("sortingReverse"),
};
const plotConf = {displayModeBar: false, responsive: true};
const plotLayout = {
    margin: { l: 20, r: 0, t: 0, b: 15 },
    showlegend: false,
    plot_bgcolor: "#fafafa",
    paper_bgcolor: "#fafafa",
    hovermode: "x",
    dragmode: "pan",
    yaxis: {
        zeroline: false,
        tickfont: {size: 10},
        ticklabelstandoff: 4,
    },
    xaxis: {
        range: [ALL_TIER_IDX, TIERS.length-1+.3],
        fixedrange: true,
        zeroline: false,
        tickvals: [...TIERS.map((_, idx) => idx), ALL_TIER_IDX],
        ticktext: [...xticklabels, `<span style="color:#fafafa;">All</span>`],
        tickfont: {size: 9},
    },
};
const layoutExtra = {
    winrate: {
        yrange: {general: [41, 60]}, selector: ".plot-wr", guideline: {
            // 50% guideline
            type: "line", x0: -1, x1: 10, y0: 50, y1: 50,
            line: {color: "black", width: .5, dash: "dot"}, layer: "between",
        }
    },
    pickrate: {
        yrange: {general: [-1, 40], tank: [-1, 20]}, selector: ".plot-pr", guideline: {
            // 0 guideline
            type: "line", x0: -1, x1: 10, y0: 0, y1: 0,
            line: {color: "#0007", width: .5, dash: ""}, layer: "between",
        }, expectedGuideline: {
            // "expected" pickrate guideline
            type: "line", x0: -1, x1: 10, // y0/y1 set depending on role
            line: {color: "black", width: .5, dash: "dot"}, layer: "between",
        }
    }
};
let rawData, dataTs, heroes, allEntries, compCode;

function processRawData(rawData) {
    const rows = [];
    for (facet of rawData) {
        for (entry of facet["rates"]) rows.push({...entry.cells, ...facet.selected, url: facet._url});
    }
    const heroes = Object.fromEntries(rawData[0]["rates"].map(e =>
        [e.hero.name, {role: e.hero.role.toLowerCase(), iconUrl: e.hero.portrait, roleIconUrl: e.hero.roleIcon}]
    ));
    return [heroes, rows];
}

function setup() {
    Object.entries(confElems).forEach(([k, elem]) => elem.addEventListener("change", render));
    [...document.querySelectorAll(".plots-title.mobile div")].forEach(
        elem => elem.addEventListener("click", mobileTogglePlots)
    );
    const infoPopup = document.querySelector(".info-popup");
    document.getElementById("infoBtn").addEventListener("click",
        () => infoPopup.classList.add("shown")
    );
    document.addEventListener("click", function(e) {
        if (e.target.id != "infoBtn" && !infoPopup.contains(e.target))
            infoPopup.classList.remove("shown");
        // for phones: unhover plot if clicked off it
        [...document.querySelectorAll(".plot")].forEach(elem => {
            if (elem.contains(e.target)) return;
            Plotly.Fx.unhover(elem);
        });
    });
    document.querySelectorAll(".plots-title.pc > div").forEach(
        elem => elem.addEventListener("click", titleClickSort)
    );
    setupColorTips();
    loadData(localStorage.uselocal ? LOCAL_JSONP_SRC : EXTERNAL_JSONP_SRC);
}

function setupColorTips() {
    const vals = [...REGIONS, ...PLATFORMS];
    const colr = [...REGION_COLORS, ...PLATFORM_COLORS];
    document.getElementById("colorTips").innerHTML = vals.map((val, i) => {
        return `<span style="color:${colr[i]}">${val}</span>`
    }).join(", ");
}

function mobileTogglePlots(evt) {
    const mainDiv = document.getElementById("main");
    mainDiv.classList.remove("mobile-show-wr", "mobile-show-pr");
    if (evt.target.classList.contains("title-wr"))
        mainDiv.classList.add(["mobile-show-wr"]);
    else if (evt.target.classList.contains("title-pr"))
        mainDiv.classList.add(["mobile-show-pr"]);
}

function titleClickSort(evt) {
    const elem = evt.target;
    let sortMode = null;
    if (elem.className.includes("-wr")) sortMode = "wr-all";
    if (elem.className.includes("-pr")) sortMode = "pr-all";
    const currentSortMode = confElems.sortingMode.value;
    const reversed = currentSortMode === sortMode ? !confElems.sortingReverse.checked : true;
    confElems.sortingMode.value = sortMode;
    confElems.sortingReverse.checked = reversed;
    render();
}

function loadData(jsonpSrc) {
    // DATA is the original API data put into a list
    const script = document.createElement("script");
    script.type = "text/javascript";
    script.src = jsonpSrc;
    document.body.appendChild(script);
}

function jsonp(data) {
    rawData = data;
    [heroes, allEntries] = processRawData(rawData);
    const rqCodes = [...new Set(rawData.map(a => a.selected.rq))];
    rqCodes.sort();
    compCode = rqCodes.at(-1);
    const dataTs = rawData[0]._ts;
    tsElem.innerHTML = moment(dataTs * 1000).fromNow();
    tsElem.title = moment(dataTs * 1000).toString();
    renderHeroes();
    render();
}

function handleConf() {
    const conf = {
        facet: confElems.facet.value,
        sortingMode: confElems.sortingMode.value,
        sortingReverse: confElems.sortingReverse.checked,
        filterRole: confElems.filterRole.value,
    };
    if (conf.facet === "region") {
        conf.facetValues = REGIONS;
        conf.facetColors = REGION_COLORS;
        conf.filterFacet = "input";
        conf.filterFacetValue = confElems.filterPlatform.value;
        conf.sortFacet = "region";
        conf.sortFacetValue = confElems.sortingRegion.value;
    } else if (conf.facet === "input") {
        conf.facetValues = PLATFORMS;
        conf.facetColors = PLATFORM_COLORS;
        conf.filterFacet = "region";
        conf.filterFacetValue = confElems.filterRegion.value;
        conf.sortFacet = "input";
        conf.sortFacetValue = confElems.sortingPlatform.value;
    }
    confElems.filterRegion.disabled = conf.facet === "region";
    confElems.filterPlatform.disabled = conf.facet === "input";
    confElems.sortingRegion.disabled = conf.facet === "input" || conf.sortingMode === "name";
    confElems.sortingPlatform.disabled = conf.facet === "region" || conf.sortingMode === "name";

    const elemWr = document.querySelector(".plots-title.pc .title-wr");
    const elemPr = document.querySelector(".plots-title.pc .title-pr");
    [elemWr, elemPr].forEach(e => e.classList.remove("active", "active-inv"));
    if (conf.sortingMode === "wr-all") {
        elemWr.classList.add("active" + (conf.sortingReverse ? "-inv" : ""));
    } else if (conf.sortingMode === "pr-all") {
        elemPr.classList.add("active" + (conf.sortingReverse ? "-inv" : ""));
    }

    return conf;
}

function renderHeroes() {
    plotsElem.innerHTML = "";
    Object.entries(heroes).forEach(([name, hero]) => {
        hero.elem = document.createElement("div");
        hero.elem.className = `entry role-${hero.role}`;
        hero.elem.innerHTML = `
        <div class="hero-name" title="${name}">${name}</div>
        <img src="${hero.iconUrl}" title="${name}">
        <div class="plot plot-wr"></div>
        <div class="plot plot-pr"></div>
        `;
        plotsElem.appendChild(hero.elem);
    });
}

function sortBy(values, key) {
    const decorated = values.map(v => [v, key(v)]);
    decorated.sort((a, b) => a[1] - b[1]);
    return decorated.map(v => v[0]);
}

function pluck(objArr, key) {
    return objArr.map(e => e[key]);
}

function render() {
    const conf = handleConf();

    // ==> Filter entries
    let entries = allEntries.filter(e => (
        e.rq === compCode &&
        e.role === "All" &&
        e.map === "all-maps" &&
        e[conf.filterFacet] == conf.filterFacetValue
    ));

    // ==> Sort heroes
    let names = Object.keys(heroes);
    // names = names.filter(n => n.toLowerCase().includes("wuya"));
    if (conf.filterRole !== "all") names = names.filter(name => heroes[name].role == conf.filterRole);
    names.sort(); // sort alphabetically by default
    if (conf.sortingMode !== "name") {
        names = sortBy(names, name => {
            const selected = entries.filter(e => e.name === name && e[conf.sortFacet] === conf.sortFacetValue);
            const e_b = selected.filter(e => e.tier === "Bronze")[0];
            const e_m = selected.filter(e => e.tier === "Master")[0];
            const e_all = selected.filter(e => e.tier === "All")[0];
            if (conf.sortingMode === "wr-delta") return e_m.winrate - e_b.winrate;
            if (conf.sortingMode === "pr-delta") return e_m.pickrate - e_b.pickrate;
            if (conf.sortingMode === "wr-all") return e_all.winrate;
            if (conf.sortingMode === "pr-all") return e_all.pickrate;
        });
    }
    if (conf.sortingReverse) names.reverse();
    Object.entries(heroes).forEach(([name, hero]) => {
        names.includes(name) ? hero.elem.classList.remove("hidden") : hero.elem.classList.add("hidden");
        hero.elem.style.order = names.indexOf(name);
    });

    // ==> Update plots
    const viewKey = `${conf.facet}${conf.filterFacetValue}`
    names.forEach((name, idx) => {
        const hero = heroes[name];
        const entryElem = hero.elem;
        entryElem.style.zIndex = names.length - idx; // fixes xtick tooltip clipping
        if (entryElem.dataset.lastViewKey === viewKey) return;
        entryElem.dataset.lastViewKey = viewKey;

        const nameEntries = entries.filter(e => e.name === name);
        ["winrate", "pickrate"].forEach(valtype => {
            // Line traces
            const traces = conf.facetValues.map(value => {
                const valueName = value == "PC" ? "KB&M" : value;
                const facetEntries = nameEntries.filter(e => (
                    e[conf.facet] === value &&
                    e[valtype] != -1
                ));
                let facetEntriesTiered = facetEntries.filter(e => e.tier !== "All");
                facetEntriesTiered = sortBy(facetEntriesTiered, e => tiersInfo[e.tier].idx);
                let points = facetEntriesTiered.map(e => ({
                    x: tiersInfo[e.tier].idx, y: e[valtype], size: 4, symbol: "circle"
                }));
                let facetEntriesTot = facetEntries.filter(e => e.tier === "All");
                if (facetEntriesTot.length) {
                    // Insert total points at the end.
                    // Dud in front breaks the line so All is disconnected from GM.
                    points = [...points, {x: TIERS.length-1}, {
                        x: ALL_TIER_IDX, y: facetEntriesTot[0][valtype], symbol: "arrow-left", size: 6,
                    }];
                }
                return {
                    x: pluck(points, "x"), y: pluck(points, "y"), mode: "lines+markers", name: valueName,
                    line: {color: conf.facetColors[conf.facetValues.indexOf(value)], width: 1.2},
                    marker: {size: pluck(points, "size"), symbol: pluck(points, "symbol"), line: {width: 0}, opacity: 1},
                };
            });

            const extraShapes = [];
            if (valtype === "pickrate") {
                const inRole = Object.values(heroes).filter(h => h.role === hero.role).length;
                const expectPr = (hero.role === "tank" ? 100 : 200) / inRole;
                extraShapes.push({y0: expectPr, y1: expectPr, ...layoutExtra.pickrate.expectedGuideline});
            }

            const yrange = layoutExtra[valtype].yrange[hero.role] || layoutExtra[valtype].yrange.general;
            const elem = entryElem.querySelector(layoutExtra[valtype].selector);
            Plotly.react(elem, traces, {
                ...plotLayout, shapes: [layoutExtra[valtype].guideline, ...extraShapes],
                yaxis: {range: yrange.slice(), ...plotLayout.yaxis},
            }, plotConf);
        });
    });
}

setup();

</script>
</body>
</html>
