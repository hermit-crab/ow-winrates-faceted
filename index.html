<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Overwatch 2 Winrates & Pickrates – Faceted</title>
<script src="https://cdn.plot.ly/plotly-3.1.0.min.js"></script>
<script src="https://momentjs.com/downloads/moment.min.js"></script>
<!-- basic analytics, just for me to know if page has any visitors and I need to maintain it -->
<script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
<style>

body {
    font-family: sans-serif;
    background: #fafafa;
    margin: 20px;
}
.main {
    display: flex;
    flex-direction: column;
    align-items: center;
}
.main > * {
    /* prevent flexbox centering overflow issue */
    margin: auto;
}

.title {
    font-size: 20px;
    text-transform: uppercase;
    text-shadow: 1px 1px 0px #0002;
    display: flex;
    align-items: center;
    font-weight: bold;
    color: #393939;
}
.title svg {
    height: 25px;
    width: 25px;
    min-width: 25px;
    min-height: 25px;
    margin-right: 10px;
}

.conf {
    margin: 10px auto;
    font-size: 90%;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: baseline;
}
.conf-block {
    display: inline-block;
    padding: 0 6px;
    text-wrap: nowrap;
    border-left: 1px solid rgba(0, 0, 0, 0.271);
}
.conf-block:first-child {
    padding-left: 0;
    border-left: none;
}

.info {
    font-size: 80%;
    opacity: 40%;
    margin-bottom: 10px;
}
.info a {
    color: black;
    text-decoration: dotted;
}
.info a:hover {
    text-decoration: underline;
}

.plots-title {
    display: flex;
    flex-wrap: nowrap;
    width: 700px;
    font-weight: bold;
    color: #5c5c5c;
    letter-spacing: 1px;
}
.plots-title > div:first-child {
    margin-left: 80px;
}
.plots-title > div {
    font-size: 60%;
    width: 300px;
    text-align: center;
    text-transform: uppercase;
    /* account for yticks space */
    padding-left: 10px;
}

.entry {
    padding-bottom: 3px;
    margin-top: 3px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.271);
    height: 100px;
    width: 700px;
    display: flex;
    position: relative;
}
.entry .hero-name {
    position: absolute;
    top: 0px;
    left: 0px;
    font-size: 80%;
    color: #0000;
}
.entry img {
    height: 80px;
    width: 80px;
    display: block;
    border-radius: 50%;
    align-self: center;
    margin-right: 10px;
}
.entry .plot {
    height: 100%;
    width: 300px;
}

</style>
</head>
<body>

<div class="main">
<div class="title">
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" aria-labelledby="blz-icon-title-overwatch-2-dark" viewBox="0 0 48 48" part="icon"><title id="blz-icon-title-overwatch-2-dark">Overwatch 2</title><path fill="#ED6516" d="M13.9 13.901a14.284 14.284 0 0 1 20.2 0l4.043-4.042a20 20 0 0 0-28.286 0z"></path><path fill="#333E48" d="m39.312 11.135-4.063 4.062a14.29 14.29 0 0 1 .995 16.159L28.891 24l-4.006-9.413h-.02V27.31l7.938 7.938a14.29 14.29 0 0 1-17.606 0l7.939-7.938V14.636l-4.027 9.365-7.355 7.355a14.29 14.29 0 0 1 .997-16.159l-4.063-4.062a20.001 20.001 0 1 0 30.624 0"></path></svg>
    Overwatch 2 Winrates & Pickrates – Faceted
</div>

<div class="conf">
    <div class="conf-block">
        Facet
        <select id="facet">
            <option value="region" selected>Region</option>
            <option value="input">Platform</option>
        </select>
    </div>
    <div class="conf-block">
        Select
        <select id="filterRole">
            <option value="all" selected>All</option>
            <option value="support">Support</option>
            <option value="tank">Tank</option>
            <option value="damage">Damage</option>
        </select>
        <select id="filterRegion">
            <option value="Americas" selected>Americas</option>
            <option value="Asia">Asia</option>
            <option value="Europe">Europe</option>
        </select>
        <select id="filterPlatform">
            <option value="PC" selected>KB&M</option>
            <option value="Console">Console</option>
        </select>
    </div>
    <div class="conf-block">
        Sort by
        <select id="sortingMode">
            <option value="wr-delta">Winrate B / M Diff.</option>
            <option value="pr-delta">Pickrate B / M Diff.</option>
            <option value="wr-all" selected>Total Winrate</option>
            <option value="pr-all">Total Pickrate</option>
            <option value="name">Name</option>
        </select>
        in facet
        <select id="sortingRegion">
            <option value="Americas" selected>Americas</option>
            <option value="Asia">Asia</option>
            <option value="Europe">Europe</option>
        </select>
        <select id="sortingPlatform">
            <option value="PC" selected>KB&M</option>
            <option value="Console">Console</option>
        </select>
        <label><input type="checkbox" id="sortingReverse" checked></input>Reversed</label>
    </div>
</div>
<div class="info">
    dataset refreshed: <span id="datasetTs"></span> ┊
    <a href="https://overwatch.blizzard.com/en-us/rates/">official source</a> ┊
    <a href="https://docs.google.com/forms/d/e/1FAIpQLSd8aEzuAdIPjHKv_0VND6HbKdywIi7SWBeIFV2k1t_3bvHaIw/viewform?usp=dialog">report issue</a> ┊
    tip: double click any plot to toggle own relative scale
</div>
<div class="plots-title"><div>Winrate</div><div>Pickrate</div></div>
<div id="plots"></div>
</div>

<script>

const TIERS = ["Bronze", "Silver", "Gold", "Platinum", "Diamond", "Master", "Grandmaster"];
const TIER_COLORS = ["#cd7850", "#c4c6c8", "#d8a43d", "#98d8b9", "#5f9ff0", "#8ae960", "#8d71fe"];
const REGIONS = ["Americas", "Asia", "Europe"];
const REGION_COLORS = ["#f14141", "#ffac00", "#3c90ff"];
const PLATFORMS = ["PC", "Console"];
// const PLATFORM_COLORS = ["#16a616", "#8d71fe"]
const PLATFORM_COLORS = ["black", "gray"];
const LOCAL_JSONP_SRC = "winrate-data.js";
const EXTERNAL_JSONP_SRC = "https://hermit-crab.neocities.org/winrate-data.js?nocache=" + parseInt(Date.now()/1000/60/60);

const tiersInfo = Object.fromEntries(TIERS.map((name, idx) => [name, {
    idx: idx,
    color: TIER_COLORS[idx],
    shorthand: name !== "Grandmaster" ? name[0] : "GM+",
}]));
const xticklabels = TIERS.map(n => `<span style="color: ${tiersInfo[n].color}; font-weight: bold">${tiersInfo[n].shorthand}</span>`);
const plotsElem = document.getElementById("plots");
const tsElem = document.getElementById("datasetTs");
const confElems = {
    facet: document.getElementById("facet"),
    filterRole: document.getElementById("filterRole"),
    filterPlatform: document.getElementById("filterPlatform"),
    filterRegion: document.getElementById("filterRegion"),
    sortingMode: document.getElementById("sortingMode"),
    sortingRegion: document.getElementById("sortingRegion"),
    sortingPlatform: document.getElementById("sortingPlatform"),
    sortingReverse: document.getElementById("sortingReverse"),
};
let rawData, dataTs;

function processData(rawData) {
    const rows = [];
    for (facet of rawData) {
        for (entry of facet["rates"]) rows.push({...entry.cells, ...facet.selected, url: facet._url});
    }
    const heroes = Object.fromEntries(rawData[0]["rates"].map(e => 
        [e.hero.name, {role: e.hero.role.toLowerCase(), iconUrl: e.hero.portrait, roleIconUrl: e.hero.roleIcon}]
    ));
    return [heroes, rows];
}

function setup() {
    Object.entries(confElems).forEach(([k, elem]) => {
        if (k === "filterRole") elem.addEventListener("change", toggleRoles);
        else elem.addEventListener("change", render);
    });
    loadData(localStorage.uselocal ? LOCAL_JSONP_SRC : EXTERNAL_JSONP_SRC);
}

function loadData(jsonpSrc) {
    const script = document.createElement("script");
    script.type = "text/javascript";
    script.src = jsonpSrc;
    document.body.appendChild(script);
}

function jsonp(data) {
    rawData = data;
    render();
}

function toggleRoles() {
    const confVal = confElems.filterRole.value;
    [...document.querySelectorAll(".entry")].forEach(elem => {
        if (confVal == "all") elem.style.display = "flex";
        else elem.style.display = elem.className.includes(confVal) ? "flex" : "none";
    });
}

function handleConf() {
    const conf = {
        facet: confElems.facet.value,
        sortingMode: confElems.sortingMode.value,
        sortingReverse: sortingReverse.checked,
    }
    if (conf.facet === "region") {
        conf.facetValues = REGIONS;
        conf.facetColors = REGION_COLORS;
        conf.filterFacet = "input";
        conf.filterFacetValue = confElems.filterPlatform.value;
        conf.sortFacet = "region";
        conf.sortFacetValue = confElems.sortingRegion.value;
    } else if (conf.facet === "input") {
        conf.facetValues = PLATFORMS;
        conf.facetColors = PLATFORM_COLORS;
        conf.filterFacet = "region";
        conf.filterFacetValue = confElems.filterRegion.value;
        conf.sortFacet = "input";
        conf.sortFacetValue = confElems.sortingPlatform.value;
    }
    confElems.filterRegion.disabled = conf.facet === "region";
    confElems.filterPlatform.disabled = conf.facet === "input";
    confElems.sortingRegion.disabled = conf.facet === "input" || conf.sortingMode === "name";
    confElems.sortingPlatform.disabled = conf.facet === "region" || conf.sortingMode === "name";
    return conf;
}

function render() {
    // DATA is the original API data put into a list, first element is extraction timestamp
    const conf = handleConf();
    const dataTs = rawData[0]._ts;
    const [heroes, allEntries] = processData(rawData);

    tsElem.innerHTML = moment(dataTs * 1000).fromNow();
    tsElem.title = moment(dataTs * 1000).toString();

    // ==> Filter
    let entries = allEntries.filter(e => (
        e.rq === "1" &&
        e.role === "All" &&
        e.map === "all-maps" &&
        e[conf.filterFacet] == conf.filterFacetValue
    ));
    
    // ==> Sort
    let names = Object.keys(heroes);
    names.sort();
    if (conf.sortingMode !== "name") {
        let sorterKey = names.map(name => {
            const selected = entries.filter(d => d.name === name && d[conf.sortFacet] === conf.sortFacetValue);
            const e_b = selected.filter(e => e.tier === "Bronze")[0];
            const e_m = selected.filter(e => e.tier === "Master")[0];
            const e_all = selected.filter(e => e.tier === "All")[0];
            if (conf.sortingMode === "wr-delta") return e_m.winrate - e_b.winrate;
            if (conf.sortingMode === "pr-delta") return e_m.pickrate - e_b.pickrate;
            if (conf.sortingMode === "wr-all") return e_all.winrate;
            if (conf.sortingMode === "pr-all") return e_all.pickrate;
        })
        names.sort((a, b) => sorterKey[names.indexOf(a)] - sorterKey[names.indexOf(b)])
    }
    if (conf.sortingReverse) names.reverse();
    
    entries = entries.filter(e => e.tier !== "All");

    // ==> Render plots
    // XXX: I fully re-render everything on any config changes, yes, that is not very good
    plotsElem.innerHTML = "";
    names.forEach(name => {
        const nameEntries = entries.filter(d => d.name === name);

        const [tracesWr, tracesPr] = ["winrate", "pickrate"].map(valtype => {
            return conf.facetValues.map(value => {
                const facetEntries = nameEntries.filter(d => d[conf.facet] === value && d[valtype] != -1);
                return {
                    x: facetEntries.map(d => tiersInfo[d.tier].idx),
                    y: facetEntries.map(d => d[valtype]),
                    mode: "lines+markers",
                    name: value == "PC" ? "KB&M" : value,
                    line: {color: conf.facetColors[conf.facetValues.indexOf(value)], width: 1.2},
                    marker: {size: 4},
                };
            });
        })
        
        const container = document.createElement("div");
        container.className = `entry role-${heroes[name].role}`;
        container.innerHTML = `
        <div class="hero-name" title="${name}">${name}</div>
        <img src="${heroes[name].iconUrl}" title="${name}">
        <div class="plot plot-wr"></div>
        <div class="plot plot-pr"></div>
        `;
        // TODO: maybe add position number near hero icon (note: roles are filtered through css)
        plotsElem.appendChild(container);

        const plotCommon = {
            margin: { l: 20, r: 0, t: 0, b: 15 },
            showlegend: false,
            plot_bgcolor: "#fafafa",
            paper_bgcolor: "#fafafa",
            hovermode: "x",
            dragmode: "pan",
            xaxis: { 
                range: [-.5, TIERS.length-.5],
                fixedrange: true,
                zeroline: false,
                tickvals: TIERS.map((_, idx) => idx),
                ticktext: xticklabels,
                tickfont: { size: 9 },
            },
        }
        const plotConf = { displayModeBar: false, responsive: true }
        Plotly.newPlot(container.querySelector(".plot-wr"), tracesWr, {
            ...plotCommon,
            yaxis: { range: [41, 60], zeroline: false, tickfont: { size: 10 }},
            shapes: [{
                type: "line", x0: -1, x1: 10, y0: 50, y1: 50,
                line: {color: "black", width: .5, dash: "dot"}
            }],
        }, plotConf);
        Plotly.newPlot(container.querySelector(".plot-pr"), tracesPr, {
            ...plotCommon,
            yaxis: { range: [-1, 40], zeroline: false, tickfont: { size: 10 }},
            shapes: [{
                type: "line", x0: -1, x1: 10, y0: 0, y1: 0,
                line: {color: "black", width: .5, dash: "dot"}
            }],
        }, plotConf);
    });

    toggleRoles();
}

setup();

</script>
</body>
</html>
