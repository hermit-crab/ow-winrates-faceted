<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8' />
<title>Overwatch 2 Winrates & Pickrates – Faceted</title>
<meta name='viewport' content='width=device-width, initial-scale=1.0' />
<script src='https://cdn.plot.ly/plotly-3.1.0.min.js'></script>
<script src='https://momentjs.com/downloads/moment.min.js'></script>
<!-- basic analytics, just for me to know if page has any visitors and I need to maintain it -->
<script async src='https://scripts.simpleanalyticscdn.com/latest.js'></script>
<style>

body {
    font-family: sans-serif;
    background: #fafafa;
    margin: 0;
}
.hidden {display: none !important;}
.flash {animation: flash 0.7s ease;}

/* -- main box -- */
#main {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 15px;
    width: 100%;
}
#main > * {
    padding-left: 10px;
    box-sizing: border-box;
    /* prevent flexbox centering overflow issue */
    margin: 0 auto;
}

/* -- title -- */
.title {
    font-size: 20px;
    text-transform: uppercase;
    text-shadow: 1px 1px 0px #0002;
    font-weight: bold;
    display: block;
    color: #393939;
    text-wrap: nowrap;
    overflow: hidden;
    text-align: center;
    padding-right: 10px;
    width: 100%;
}
.title > * {
    vertical-align: middle;
}
.title svg {
    height: 25px;
    width: 25px;
    min-width: 25px;
    min-height: 25px;
    margin-right: 5px;
}

/* -- conf+info box -- */
.scroller {
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow-x: auto;
    width: 100%;
    margin-bottom: 5px !important;
    padding-bottom: 5px;
}

/* -- conf -- */
.conf {
    margin: 10px auto !important;
    font-size: 90%;
    display: flex;
    flex-wrap: nowrap;
    justify-content: center;
    align-items: baseline;
    user-select: none;
}
.conf-block {
    display: inline-block;
    padding: 0 6px;
    text-wrap: nowrap;
    border-left: 1px solid rgba(0, 0, 0, 0.271);
}
.conf-block:first-child {
    padding-left: 0;
    border-left: none;
}
.sorting-reversed {
    display: none;
}
.conf #facet option:disabled {
    display: none;
}
.conf input[type='checkbox'] {
    vertical-align: bottom;
}

/* -- info line -- */
.info, .warnings {
    font-size: 80%;
    opacity: 50%;
    text-wrap: nowrap;
    margin: 0 auto;
}
.info a {
    color: black;
    text-decoration: dotted;
}
.info a:hover {
    text-decoration: underline;
}
.warnings > *:last-child::after {
    content: '┊';
    opacity: 0;
}
.warnings > * {
    color: #871818;
}
.info .trigger-info,
.warnings .trigger-info {
    background: none;
    border: none;
    padding: 0;
    font: inherit;
    cursor: pointer;
}
.info .trigger-info:hover,
.warnings .trigger-info:hover {
    text-decoration: underline dotted;
}

/* -- info popup -- */
.info-popup {
    position: absolute;
    font-size: 90%;
    top: 10px;
    left: 10px;
    margin-right: 10px;
    z-index: 500;
    background-color: white;
    font-size: 90%;
    padding: 20px;
    max-width: 600px;
    box-shadow: 6px 6px #0004, 0 0 0 1px #0001;
}
.info-popup ul {
    margin: 0;
    padding-left: 15px;
}
.info-popup > ul > li {
    margin-bottom: 3px;
}
#colorTips {
    font-weight: bold;
}
#infoPopupClose {
    position: absolute;
    top: 5px;
    right: 5px;
}

/* -- column titles -- */
.plots-title {
    display: flex;
    flex-wrap: nowrap;
    font-weight: bold;
    color: #5c5c5c;
    letter-spacing: 1px;
    font-size: 60%;
    gap: 10px;
    user-select: none;
    position: relative;
}
.plots-title .col {
    text-align: right;
    text-transform: uppercase;
    width: 300px;
    margin: auto;
}
.plots-title .col span {
    cursor: pointer;
    margin-right: 10px;
    text-wrap: nowrap;
}
.plots-title .col.title-name {
    width: 80px;
    cursor: default;
}
.plots-title .col.title-name span {
    margin-right: 0;
}

.plots-title .col span:before {
    content: '▼ ';
    visibility: hidden;
    opacity: 80%;
}
.plots-title .col.active span:before {
    content: '▲ ';
}
.plots-title .col.active.inv span:before {
    content: '▼ ';
}
.plots-title .col.active span:before,
.plots-title .col.active.inv span:before {
    visibility: visible;
}
.plots-title .col span:hover:before {
    visibility: visible;
}

#selectColumn {
    display: none;
    box-shadow: 0 0 1px 0 gray;
    border-radius: 2px;
    padding: 0 4px;
    opacity: 70%;
    top: 0;
    position: absolute;
    left: 80px;
    text-transform: uppercase;
    height: 20px;
}

/* -- hero entries box -- */
#plots {
    margin-bottom: 200px;
    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
}

/* -- hero entries -- */
.entry {
    padding-bottom: 3px;
    margin-top: 3px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.271);
    height: 100px;
    display: flex;
    position: relative;
    column-gap: 10px;
}
.entry .hero-name {
    position: absolute;
    top: 0px;
    left: 0px;
    font-size: 80%;
    color: #0000;
}
.entry img {
    height: 80px;
    width: 80px;
    display: block;
    border-radius: 50%;
    align-self: center;
}
.entry .plot-parent {
    position: relative;
}
.entry .plot {
    height: 100px;
    width: 300px;
}
.entry .stub {
    height: 100px;
    width: 300px;
    display: none;
    position: absolute;
    top: 0;
    left: 0;
}
svg.main-svg, svg.main-svg * {
    /* allow xtick tooltipx overflow */
    overflow: visible;
}

/* -- mobile -- */
@media screen and (max-width: 700px) {
    .conf {justify-content: left;}
    .title {font-size: 100%;}
    .entry img {height: 60px; width: 60px;}
    .plots-title .col.title-name {width: 60px;}
    #selectColumn {display:inline-block;}
    .entry .stub {display: block;}
    .mobile-focused .stub {display: none;}
    .mobile-focused .plot {box-shadow: -5px 0 0 #0004;}
    .plots-title {
        background-color: #fafafa;
        height: 20px;
        font-size: 80%;
        padding: 3px 0;
        position: sticky;
        z-index: 400;
        top: 0;
    }
    .plot-parent.pr {display: none;}
    .plot-parent.wr {display: none;}
    .title-wr {display: none;}
    .title-pr {display: none;}

    .mobile-show-pr .plot-parent.pr {display: block;}
    .mobile-show-pr .title-pr {display: block;}
    .mobile-show-wr .plot-parent.wr {display: block;}
    .mobile-show-wr .title-wr {display: block;}
}

@keyframes flash {
    0%   {background-color: transparent;}
    50%  {background-color: rgba(74, 210, 255, 0.518);}
    100% {background-color: transparent;}
}
</style>
</head>
<body>

<div class='info-popup hidden'>
    <button id='infoPopupClose'>x</button>
    <ul>
        <li>Line colors: <span id='colorTips'></span>.</li>
        <li><b>Hover</b> (or click on mobile) on any plot to see exact values and legend at near position.</li>
        <li><b>Double click</b> any plot to zoom in/out (toggle own relative scale).</li>
        <li>Starting "<b>All</b>" values represent Competitive total values across all tiers.</li>
        <li><b>Dashed</b> lines represens "expected" value. For winrate it's 50%.
            For pickrate it's the value that would result if every hero was equally desirable within their role.</li>
        <li>Special <b>sorting</b> modes:<ul>
            <li>B / M Diff. – difference between Bronze and Master (slope of the facet line).</li>
            <li>Facet Diff. – variance between facet lines (calculated as MAD from mean line).</li>
        </ul></li>
        <li><b>*Average</b> (mean) values are computed by this page (Blizzard does not provide it).
        Since we do not know population sizes (weights) – our mean is only an estimate of true mean.</li>
        <li><b>Chinese</b> data comes from a <a href='https://ow.blizzard.cn/herolist/'>separate official source</a>.
            I do not know if the numbers are calculated in the exact same manner as on the main site.<ul>
            <li>There is no PC/Console separation (is it even available on Consoles there).</li>
            <li>It provides QP data broken down by ranks (huh!), so you can also facet by Game Mode.</li>
            <li>It provides independant Champ data (main site bundles it with GM), this page ignores it.</li>
            <li>It provides Stadium data, this page ignores it (for now).</li>
        </ul></li>
    </ul>
</div>

<div id='main' class='mobile-show-wr'>

<div class='title'>
    <svg xmlns='http://www.w3.org/2000/svg' fill='none' aria-labelledby='blz-icon-title-overwatch-2-dark' viewBox='0 0 48 48' part='icon'><title id='blz-icon-title-overwatch-2-dark'>Overwatch 2</title><path fill='#ED6516' d='M13.9 13.901a14.284 14.284 0 0 1 20.2 0l4.043-4.042a20 20 0 0 0-28.286 0z'></path><path fill='#333E48' d='m39.312 11.135-4.063 4.062a14.29 14.29 0 0 1 .995 16.159L28.891 24l-4.006-9.413h-.02V27.31l7.938 7.938a14.29 14.29 0 0 1-17.606 0l7.939-7.938V14.636l-4.027 9.365-7.355 7.355a14.29 14.29 0 0 1 .997-16.159l-4.063-4.062a20.001 20.001 0 1 0 30.624 0'></path></svg>
    <span>Overwatch 2 Winrates & Pickrates – Faceted</span>
</div>

<div class='scroller'>
<div class='conf'>
    <div class='conf-block facet-block'>
        Facet
        <select id='facet'>
            <option value='region' selected>Region</option>
            <option value='input'>Platform</option>
            <option value='mode' disabled>Mode</option>
        </select>
    </div>
    <div class='conf-block'>
        Select
        <select id='filterRole'>
            <option value='all' selected>Role</option>
            <option value='support'>Support</option>
            <option value='tank'>Tank</option>
            <option value='damage'>Damage</option>
        </select>
        <select id='filterRegion'>
            <option value='all' selected>Region</option>
            <option value='Americas'>Americas</option>
            <option value='Asia'>Asia</option>
            <option value='Europe'>Europe</option>
            <option value='China'>China</option>
            <option value='mean'>*Average</option>
        </select>
        <select id='filterPlatform'>
            <option value='PC' selected>KB&M</option>
            <option value='Console'>Console</option>
        </select>
        <label class='toggle-china' title='China'>
            <input type='checkbox' id='toggleChina'></input>CN
        </label>
    </div>
    <div class='conf-block'>
        Sort mode
        <select id='sortingMode'>
            <option value='all' selected>All Ranks</option>
            <option id='sortTiers'>...replaced via JS</option>
            <option value='b-m-delta'>B / M Diff.</option>
            <option value='facets-spread'>Facet Diff.</option>
        </select>
        in facet
        <select id='sortingRegion'>
            <option value='Americas' selected>Americas</option>
            <option value='Asia'>Asia</option>
            <option value='Europe'>Europe</option>
            <option value='China'>China</option>
            <option value='mean'>*Average</option>
        </select>
        <select id='sortingPlatform'>
            <option value='PC' selected>KB&M</option>
            <option value='Console'>Console</option>
        </select>
        <select id='sortingGameMode'>
            <option value='Comp' selected>Comp</option>
            <option value='QP'>QP</option>
        </select>
        <label class='sorting-reversed'>
            <input type='checkbox' id='sortingReverse' checked></input>Reversed
        </label>
    </div>
</div>

<div class='info'>
    <button class='trigger-info'>legend and info ★</button> ┊
    dataset refreshed: <span id='datasetTs'></span> ┊
    <a href='https://overwatch.blizzard.com/en-us/rates/'>official source</a> ┊
    <a href='https://docs.google.com/forms/d/e/1FAIpQLSd8aEzuAdIPjHKv_0VND6HbKdywIi7SWBeIFV2k1t_3bvHaIw/viewform?usp=dialog'>report issue</a>
</div>
<div class='warnings hidden'></div>
</div>

<div class='plots-title'>
    <div class='col title-name' data-sort='name'><span>Hero</span></div>
    <div class='col title-wr active' data-sort='winrate'><span>Winrate</span></div>
    <div class='col title-pr' data-sort='pickrate'><span>Pickrate</span></div>
    <select id='selectColumn'>
        <option value='wr' selected>Winrate</option>
        <option value='pr'>Pickrate</option>
    </select>
</div>

<div id='plots'></div>

</div>

<script>
'use strict';

const TIERS = ['Bronze', 'Silver', 'Gold', 'Platinum', 'Diamond', 'Master', 'Grandmaster'];
// const SD_TIERS = ['Rookie', 'Novice', 'Contender', 'Elite', 'Pro', 'AllStar', 'Legend'];
const TIER_COLORS = ['#cd7850', '#c4c6c8', '#d8a43d', '#98d8b9', '#5f9ff0', '#8ae960', '#8d71fe'];
const REGIONS = ['Americas', 'Asia', 'Europe', 'China', 'mean'];
const REGION_COLORS = ['#f14141', '#ffac00', '#3c90ff', '#58d986', 'black'];
const PLATFORMS = ['PC', 'Console'];
const EXTRA_COLORS = {Console: '#999', QP: '#afafa5ff'};
const ROLES = ['tank', 'support', 'damage'];
const LOCAL_JSONP_SRC = 'winrate-data.js';
const EXTERNAL_JSONP_SRC = 'https://hermit-crab.neocities.org/winrate-data.js?nocache=' + parseInt(Date.now()/1000/60/60);
const ALL_TIER_IDX = -.5;
const PRETTY_NAMES = {'PC': 'KB&M', 'mean': '*Average'};
const WARNINGS = {
    cn: 'see notes about CN data',
    avg: 'synthetic unweighted *Average',
};

const tiersInfo = Object.fromEntries(TIERS.map((name, idx) => [name, {
    idx: idx,
    color: TIER_COLORS[idx],
    shorthand: name !== 'Grandmaster' ? name[0] : 'GM+',
}]));
const xticklabels = TIERS.map(n => `<span style='color: ${tiersInfo[n].color}; font-weight: bold'>${tiersInfo[n].shorthand}</span>`);
const plotsElem = document.querySelector('#plots');
const confElems = {
    facet: document.querySelector('#facet'),
    filterRole: document.querySelector('#filterRole'),
    filterPlatform: document.querySelector('#filterPlatform'),
    filterRegion: document.querySelector('#filterRegion'),
    sortingMode: document.querySelector('#sortingMode'),
    sortingRegion: document.querySelector('#sortingRegion'),
    sortingPlatform: document.querySelector('#sortingPlatform'),
    sortingGameMode: document.querySelector('#sortingGameMode'),
    sortingReverse: document.querySelector('#sortingReverse'),
    toggleChina: document.querySelector('#toggleChina'),
};
const plotConf = {displayModeBar: false, responsive: true, scrollZoom: false, doubleClick: false};
const plotLayout = {
    margin: { l: 20, r: 0, t: 0, b: 15 },
    showlegend: false,
    plot_bgcolor: '#fafafa',
    paper_bgcolor: '#fafafa',
    hovermode: 'x',
    dragmode: 'pan',
    yaxis: {
        zeroline: false,
        tickfont: {size: 10},
        ticklabelstandoff: 4,
    },
    xaxis: {
        range: [ALL_TIER_IDX, TIERS.length-1+.3],
        fixedrange: true,
        zeroline: false,
        tickvals: [...TIERS.map((_, idx) => idx), ALL_TIER_IDX],
        ticktext: [...xticklabels, `<span style='color:#fafafa;'>All</span>`],
        tickfont: {size: 9},
    },
};
const layoutExtra = {
    winrate: {
        yrange: {general: [41, 59]}, selector: '.plot.wr', guideline: {
            // 50% guideline
            type: 'line', x0: -1, x1: 10, y0: 50, y1: 50,
            line: {color: 'black', width: .5, dash: 'dot'}, layer: 'between',
        }
    },
    pickrate: {
        yrange: {general: [-1, 40], tank: [-1, 20]}, selector: '.plot.pr', guideline: {
            // 0 guideline
            type: 'line', x0: -1, x1: 10, y0: 0, y1: 0,
            line: {color: '#0007', width: .5, dash: ''}, layer: 'between',
        }, expectedGuideline: {
            // 'expected' pickrate guideline
            type: 'line', x0: -1, x1: 10, // y0/y1 set depending on role
            line: {color: 'black', width: .5, dash: 'dot'}, layer: 'between',
        }
    }
};
let rawData, dataTs, heroes, allEntries, expectedPr, regionMeans, regionMeansWithCN, lastConf = {};
setup();


function setup() {
    Object.entries(confElems).forEach(([k, elem]) => elem.addEventListener('change', render));
    document.querySelector('#selectColumn').addEventListener('change', mobileSelectColumns);
    const infoPopup = document.querySelector('.info-popup');
    document.querySelector('#infoPopupClose').addEventListener('click',
        () => infoPopup.classList.add('hidden')
    );
    document.addEventListener('click', function(e) {
        if (!e.target.classList.contains('trigger-info') && !infoPopup.contains(e.target))
            infoPopup.classList.add('hidden');
        else if (e.target.classList.contains('trigger-info'))
            infoPopup.classList.remove('hidden');
        // for phones: unhover/unfocus plot if clicked off it
        document.querySelectorAll('.plot.js-plotly-plot').forEach(plot => {
            if (e.target.classList.contains('stub') && e.target.parentElement.contains(plot)) return;
            if (plot.contains(e.target)) return;
            Plotly.Fx.unhover(plot);
            mobileFocusPlot(plot.parentElement, false);
        });
    });
    document.querySelectorAll('.plots-title .col span').forEach(
        elem => elem.addEventListener('click', titleClickSort)
    );
    const tierTitles = [...TIERS.slice(0, TIERS.length-1), 'GM+'];
    document.querySelector('#sortTiers').outerHTML = TIERS.map((v, i) =>
        `<option value='tier-${v}'>:${tierTitles[i]}</option>`
    ).join('\n');
    setupColorTips();
    loadData(localStorage.uselocal ? LOCAL_JSONP_SRC : EXTERNAL_JSONP_SRC);
}


function loadData(jsonpSrc) {
    const script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = jsonpSrc;
    document.body.appendChild(script);
}


function jsonp(data) {
    rawData = data;
    [heroes, allEntries] = processRawData(rawData);
    regionMeans = computeRegionMeans(allEntries.filter(e => e.region !== 'China'));
    regionMeansWithCN = computeRegionMeans(allEntries);
    expectedPr = Object.fromEntries(ROLES.map(role =>
        [role, (role === 'tank' ? 100 : 200) / Object.values(heroes).filter(h => h.role === role).length]
    ));
    const dataTs = rawData[0]._ts;
    const tsElem = document.querySelector('#datasetTs');
    tsElem.innerHTML = moment(dataTs * 1000).fromNow();
    tsElem.title = moment(dataTs * 1000).toString();
    renderHeroes();
    render();
}


function processRawData(rawData) {
    const mainData = rawData.filter(o => o._url.includes('blizzard.com'));
    const cnData = rawData.filter(o => o._url.includes('blizzard.cn'));
    const rows = [];

    const select = (o, keys) => Object.fromEntries(keys.map(k => [k, o[k]]));

    // NOTE: On main site pickrates data sum up to 500% [sum(tank)=100 + sum(support)=200 + sum(damage)=200]
    // in CN data it is all normalized to sum up to 100%. We stick to main site convention so
    // CN data will be rescaled to it.

    // NOTE: Main site data bundles GM+Champ together, CN data gives Champ as is. We ignore it.

    const rqCodes = [...new Set(mainData.map(a => a.selected.rq))];
    rqCodes.sort();
    if (rqCodes.length !== 2)
        console.error('unexpected amount of rqCodes (expected 2)', rqCodes);
    let modes = Object.fromEntries([[rqCodes[0], 'QP'], [rqCodes[1], 'Comp']])
    for (const facet of mainData) {
        for (const entry of facet['rates'])
            rows.push({
                hero: entry.id,
                mode: modes[facet.selected.rq],
                url: facet._url,
                ...select(entry.cells, ['winrate', 'pickrate']),
                ...select(facet.selected, ['map', 'input', 'region', 'tier']),
            });
    }

    const heroes = Object.fromEntries(mainData[0]['rates'].map(e =>
        [e.id, {
            name: e.hero.name,
            role: e.hero.role.toLowerCase(),
            color: e.hero.color,
            iconUrl: e.hero.portrait,
            roleIconUrl: e.hero.roleIcon,
        }]
    ));

    // const sd2comp = Object.fromEntries(TIERS.map((t, i) => [SD_TIERS[i], t]));
    modes = {kuaisu: 'QP', jingji: 'Comp', juedou: 'Stadium'};
    for (const facet of cnData) {
        const selected = Object.fromEntries(new URL(facet._url).searchParams);
        const rolesTotalPR = Object.fromEntries(ROLES.map(r => [r, facet.data.filter(
            e => heroes[e.hero_id].role === r
        ).map(e => e.selection_ratio).reduce(sum, 0)]));
        for (const entry of facet['data']) {
            if (selected.mmr === 'Champion') continue;
            if (modes[selected.game_mode] === 'Stadium') continue;
            let tier = selected.mmr === '-127' ? 'All' : selected.mmr;
            const role = heroes[entry.hero_id].role;
            const totPR = rolesTotalPR[role] / (role === 'tank' ? 1 : 2);
            rows.push({
                hero: entry.hero_id,
                url: facet._url,
                winrate: entry.win_ratio,
                pickrate: Math.round(entry.selection_ratio / totPR * 1000) / 10,
                banrate: entry.ban_ratio,
                kda: entry.kda,
                mode: modes[selected.game_mode],
                // tier: sd2comp[tier] || tier,
                tier: tier,
                map: 'all-maps', input: 'PC', region: 'China'
            });
        }
    }

    return [heroes, rows];
}


function renderHeroes() {
    plotsElem.innerHTML = '';
    Object.entries(heroes).forEach(([id, hero]) => {
        hero.elem = document.createElement('div');
        hero.elem.className = `entry role-${hero.role}`;
        hero.elem.innerHTML = `
        <div class='hero-name' title='${hero.name}'>${hero.name}</div>
        <img src='${hero.iconUrl}' title='${hero.name}'>
        <div class='plot-parent wr'><div class='plot wr'></div><div class='stub'></div></div>
        <div class='plot-parent pr'><div class='plot pr'></div><div class='stub'></div></div>
        `;
        // We added an invisible overlay (stub) to prevent plot from stealing mobile drag-scroll.
        // We hide that scroll on click.
        hero.elem.querySelectorAll('.plot-parent').forEach(
            elem => elem.addEventListener('click', evt => mobileFocusPlot(elem, true, evt))
        );
        plotsElem.appendChild(hero.elem);
    });
}


function render() {
    const conf = handleConf();
    const smallScreen = window.matchMedia("(max-width: 700px)").matches;

    let entries = [...allEntries, ...(conf.chinaOn ? regionMeansWithCN : regionMeans)];

    // ==> Filter entries
    entries = entries.filter(e => (
        e.map === 'all-maps' &&
        (e.mode === 'Comp' || conf.facet === 'mode') &&
        (e.input === conf.filterPlatform || conf.facet === 'input') &&
        (e.region === conf.filterRegion || ['all', 'mean'].includes(conf.filterRegion)) &&
        (e.region !== 'China' || conf.chinaOn)
    ));
    if (conf.filterRegion === 'mean' && conf.facet === 'input')
        entries = entries.filter(e => e.region === conf.filterRegion);

    // ==> Sort heroes
    let names = Object.keys(heroes);
    // names = names.filter(n => n.includes('wuya'));
    if (conf.filterRole !== 'all') names = names.filter(name => heroes[name].role == conf.filterRole);
    const name2entries = Object.fromEntries(names.map(n => [n, entries.filter(e => e.hero === n)]));
    names.sort(); // sort alphabetically by default
    if (conf.sortingColumn !== 'name') {
        const dummy = {winrate: 0, pickrate: 0};
        const c = conf.sortingColumn;
        names = sortBy(names, name => {
            let entries = name2entries[name].filter(e => e[c] !== -1);
            if (conf.sortingMode !== 'facets-spread')
                entries = entries.filter(e => e[conf.sortFacet] === conf.sortFacetValue);
            let byTier = Object.fromEntries(TIERS.map(t => [t, entries.filter(e => e.tier === t)]));
            if (conf.sortingMode === 'facets-spread')
                return calcMAD(Object.values(byTier).map(lst => pluck(lst, c)));
            Object.entries(byTier).forEach(([k, v]) => {byTier[k] = v[0] || dummy;}); // fill missing data
            const eAll = entries.filter(e => e.tier === 'All')[0] || dummy;
            if (conf.sortingMode === 'all') return eAll[c];
            if (conf.sortingMode === 'b-m-delta') return byTier.Master[c] - byTier.Bronze[c];
            if (conf.sortingMode.startsWith('tier-')) return byTier[conf.sortingMode.slice(5)][c];
        });
    }
    if (conf.sortingReverse) names.reverse();
    Object.entries(heroes).forEach(([name, hero]) => {
        hero.elem.classList.toggle('hidden', !names.includes(name));
        hero.elem.style.order = names.indexOf(name);
    });

    // ==> Update plots
    const viewKey = `${conf.facet}${conf.filterRegion}${conf.filterPlatform}${conf.chinaOn}`;
    names.forEach((name, idx) => {
        const hero = heroes[name];
        const entryElem = hero.elem;
        entryElem.style.zIndex = names.length - idx; // fixes xtick tooltip clipping
        if (entryElem.dataset.lastViewKey === viewKey) return;
        entryElem.dataset.lastViewKey = viewKey;
        clearTimeout(hero.renderTimeout);

        ['winrate', 'pickrate'].forEach(valtype => {
            // Line traces
            const traces = conf.facetValues.map(facetValue => {
                const facetEntries = name2entries[name].filter(e => (
                    e[conf.facet] === facetValue && e[valtype] !== -1
                ));

                // Insert total points at the end.
                // Dud in front breaks the line so All is disconnected from GM.
                const points = [...TIERS, null, 'All'].map((t, idx) => {
                    if (!t) return {x: TIERS.length-1};
                    let entry = facetEntries.filter(e => e.tier === t);
                    if (entry.length > 1) throw Error(`unexpected multiple entries after filter`);
                    entry = entry[0];
                    if (!entry) return;
                    if (t === 'All')
                        return {x: ALL_TIER_IDX, y: entry[valtype], symbol: 'arrow-left', size: 6};
                    return {x: idx, y: entry[valtype], symbol: 'circle', size: 4};
                }).filter(e => e);

                let extraAttrs = {};
                let size = pluck(points, 'size');
                if (conf.filterRegion === 'mean' && facetValue !== 'mean' && conf.facet === 'region') {
                    extraAttrs = {hoverinfo: 'skip', opacity: .45};
                    size = [...size.slice(0, -1).map(_ => 0), size.at(-1)];
                }

                return {
                    x: pluck(points, 'x'), y: pluck(points, 'y'),
                    name: PRETTY_NAMES[facetValue] || facetValue,
                    mode: 'lines+markers',
                    line: {color: conf.facetColors[conf.facetValues.indexOf(facetValue)], width: 1.2},
                    marker: {size: size, symbol: pluck(points, 'symbol'), line: {width: 0}, opacity: 1},
                    ...extraAttrs,
                };
            });

            const shapes = [layoutExtra[valtype].guideline];
            if (valtype === 'pickrate')
                shapes.push({y0: expectedPr[hero.role], y1: expectedPr[hero.role], ...layoutExtra.pickrate.expectedGuideline});

            const yrange = layoutExtra[valtype].yrange[hero.role] || layoutExtra[valtype].yrange.general;
            const elem = entryElem.querySelector(layoutExtra[valtype].selector);
            hero.renderTimeout = setTimeout(() => {
                // Schedule updates one after another with a minor delay for better UX.
                // (doing all in one go takes .8-1s of stagger)
                Plotly.react(elem, traces, {
                    ...plotLayout, shapes: shapes,
                    yaxis: {range: yrange.slice(), ...plotLayout.yaxis},
                }, plotConf);
                elem._defaultYrange = yrange.slice();
                elem.removeAllListeners('plotly_doubleclick');
                elem.on('plotly_doubleclick', () => plotToggleZoom(elem));
            }, 30 * idx);
        });
    });
}


function computeRegionMeans(entries) {
    const staticFields = ['hero', 'mode', 'map', 'input', 'tier'];
    const computeFor = ['winrate', 'pickrate'];
    const calcMean = (objs, k) => {
        const vals = objs.map(o => o[k]).filter(v => v !== -1);
        if (!vals.length) return -1;
        return Math.round(vals.reduce(sum, 0) / vals.length * 10) / 10;
    };
    const groups = {};
    entries.forEach(e => {
        const key = staticFields.map(k => e[k]).join(',');
        if (!groups[key]) groups[key] = [Object.fromEntries(staticFields.map(k => [k, e[k]]))];
        groups[key].push(e);
    });
    return Object.values(groups).map(group => {
        const copy = group.shift();
        return {
            region: 'mean',
            ...copy,
            ...Object.fromEntries(computeFor.map(k => [k, calcMean(group, k)])),
        }
    });
}


function handleConf() {
    // XXX: Logic in this is probably getting too hairy,
    // consider view binding or a different pattern.
    const conf = {
        facet: confElems.facet.value,
        chinaOn: confElems.toggleChina.checked,
        sortingMode: confElems.sortingMode.value,
        sortingReverse: confElems.sortingReverse.checked,
        filterRole: confElems.filterRole.value,
        filterRegion: confElems.filterRegion.value,
        filterPlatform: confElems.filterPlatform.value,
    };
    confElems.sortingRegion.disabled = false;
    confElems.sortingPlatform.disabled = false;
    confElems.filterPlatform.disabled = false;
    confElems.filterRegion.disabled = false;
    if (conf.facet === 'region') {
        if (lastConf.facet !== 'region')
            confElems.filterRegion.value = conf.filterRegion = 'all';
        conf.facetValues = REGIONS;
        conf.facetColors = REGION_COLORS;
        conf.sortFacet = 'region';
        conf.sortFacetValue = confElems.sortingRegion.value;
        if (conf.filterRegion !== 'all') {
            confElems.sortingRegion.value = conf.filterRegion;
            confElems.sortingRegion.disabled = true;
            conf.sortFacetValue = conf.filterRegion;
        }
        if (conf.filterRegion !== 'mean')
            conf.facetValues = REGIONS.slice(0, -1);
    } else if (conf.facet === 'input') {
        conf.sortFacet = 'input';
        conf.sortFacetValue = confElems.sortingPlatform.value;
        confElems.filterPlatform.disabled = true;
        if (conf.filterRegion === 'all')
            confElems.filterRegion.value = conf.filterRegion = REGIONS[0];
        conf.facetValues = PLATFORMS;
        conf.facetColors = [REGION_COLORS[REGIONS.indexOf(conf.filterRegion)], EXTRA_COLORS.Console];
    } else if (conf.facet === 'mode') {
        conf.sortFacet = 'mode';
        conf.sortFacetValue = confElems.sortingGameMode.value;
        // force only CN for now
        confElems.filterRegion.value = conf.filterRegion = 'China';
        confElems.filterRegion.disabled = true;
        conf.facetValues = ['Comp', 'QP'];
        conf.facetColors = [REGION_COLORS[REGIONS.indexOf(conf.filterRegion)], EXTRA_COLORS.QP];
    }

    // will only show all regions if faceted by region
    const filterRegionAll = confElems.filterRegion.children[0];
    filterRegionAll.disabled = conf.facet !== 'region';

    // hide non applicable sort facets
    Object.entries({
        'region': confElems.sortingRegion,
        'input': confElems.sortingPlatform,
        'mode': confElems.sortingGameMode,
    }).forEach(([f, elem]) => {
        elem.classList.toggle('hidden', conf.facet !== f);
        if (conf.sortingMode === 'facets-spread') elem.disabled = true;
    });

    // pick sort column
    const columnTitleElem = document.querySelector('.plots-title .active');
    conf.sortingColumn = columnTitleElem.dataset.sort;
    columnTitleElem.classList.toggle('inv', conf.sortingReverse);

    // maintain CN on/off state
    document.querySelectorAll('select option[value="China"]').forEach(elem => elem.disabled = !conf.chinaOn);
    confElems.facet.querySelector('option[value="mode"]').disabled = !conf.chinaOn;
    if (!conf.chinaOn && lastConf.chinaOn) {
        // turning off
        if (conf.sortFacetValue === 'China')
            confElems.sortingRegion.value = REGIONS[0];
        if (conf.filterRegion === 'China')
            confElems.filterRegion.value = REGIONS[0];
        if (conf.facet === 'mode')
            confElems.facet.value = 'region';
        lastConf.chinaOn = false;
        return handleConf();
    } else if (conf.chinaOn && !lastConf.chinaOn) {
        // turning on
        if (!lastConf.chinaOn) flash(document.querySelector('.conf .facet-block'), 'flash');
    }

    // highlight sort column
    if (lastConf.sortingMode !== conf.sortingMode || lastConf.sortFacetValue !== conf.sortFacetValue)
        flash(document.querySelector('.plots-title .col.active span'), 'flash');

    toggleWarnings(conf);

    lastConf = conf;
    return conf;
}


function toggleWarnings(conf) {
    const html = [
        [WARNINGS.cn, conf.chinaOn],
        [WARNINGS.avg, conf.filterRegion === 'mean' || conf.sortFacetValue === 'mean'],
    ].map(
        ([text, cond]) => cond ? `<span class="trigger-info">${text}</span>` : null
    ).filter(t => t).join(' ┊ ');
    const warnElem = document.querySelector('.warnings')
    warnElem.classList.toggle('hidden', !html);
    warnElem.innerHTML = html;
}


function setupColorTips() {
    const vals = [...REGIONS.slice(0, -1), 'Console'];
    const colr = [...REGION_COLORS.slice(0, -1), EXTRA_COLORS.Console];
    document.querySelector('#colorTips').innerHTML = vals.map((val, i) => {
        return `<span style='color:${colr[i]}'>${val}</span>`
    }).join(', ');
}


function mobileSelectColumns() {
    const mainDiv = document.querySelector('#main');
    mainDiv.classList.remove([...mainDiv.classList].filter(c => c.startsWith('mobile-show-')));
    mainDiv.classList.add('mobile-show-' + document.querySelector('#selectColumn').value)
}


function titleClickSort(evt) {
    const elem = evt.target.parentElement;
    const active = elem.classList.contains('active');
    document.querySelectorAll('.plots-title .col').forEach(e => e.classList.remove('active', 'inv'));
    elem.classList.add('active');
    if (active) confElems.sortingReverse.checked = !confElems.sortingReverse.checked;
    else confElems.sortingReverse.checked = true;
    render();
}


function plotToggleZoom(elem) {
    const default_ = elem._defaultYrange;
    const cur = elem._fullLayout.yaxis.range;
    if (default_[0] !== cur[0] && default_[1] !== cur[1]) {
        Plotly.relayout(elem, {'yaxis.range': default_.slice()});
        return;
    }
    let traces = elem._fullData;
    if (lastConf.filterRegion === 'mean' && lastConf.facet === 'region')
        // in mean view we only show regional traces for faint reference
        traces = [traces.at(-1)];
    const ys = traces.flatMap(trace => trace.y).filter(v => v != null);
    Plotly.relayout(elem, {'yaxis.range': [Math.min(...ys)-1, Math.max(...ys)+1]});
}


function mobileFocusPlot(plotParent, focus = true, evt = null) {
    if (focus && !plotParent.classList.contains('mobile-focused')) {
        // the stub will be hidden, now propagate hover into the plot itself
        const plot = plotParent.querySelector('.plot');
        const rect = plotParent.getBoundingClientRect();
        Plotly.Fx.hover(plot, {
            xpx: evt.clientX - rect.left - plot._fullLayout.margin.l,
            ypx: evt.clientY - rect.top,
        });
    }
    plotParent.classList.toggle('mobile-focused', focus);
}


function sortBy(values, key) {
    const decorated = values.map(v => [v, key(v)]);
    decorated.sort((a, b) => a[1] - b[1]);
    return decorated.map(v => v[0]);
}


function pluck(objArr, key) {
    return objArr.map(e => e[key]);
}


function calcMAD(bins) {
    const totPoints = bins.flatMap(vals => vals.length).reduce(sum, 0);
    return bins.map(vals => {
        if (vals.length <= 1) return 0;
        const mean = vals.reduce(sum, 0) / vals.length;
        return vals.map(v => Math.abs(v-mean)).reduce(sum, 0)
    }).reduce(sum, 0) / totPoints;
}


function flash(elem, className) {
    elem.classList.remove(className);
    setTimeout(() => elem.classList.add(className), 0);
}


function sum(a, b) {return a+b;}

</script>
</body>
</html>
