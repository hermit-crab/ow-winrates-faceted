<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8' />
<title>Overwatch 2 Winrates & Pickrates – Faceted</title>
<meta name='viewport' content='width=device-width, initial-scale=1.0' />
<script src='https://cdn.plot.ly/plotly-3.1.0.min.js'></script>
<script src='https://momentjs.com/downloads/moment.min.js'></script>
<!-- basic analytics, just for me to know if page has any visitors and I need to maintain it -->
<script async src='https://scripts.simpleanalyticscdn.com/latest.js'></script>
<style>

body {
    font-family: sans-serif;
    background: #fafafa;
    margin: 0;
}
.hidden {display: none !important;}
.flash {animation: flash 0.7s ease;}

/* -- main box -- */
#main {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 10px;
    width: 100%;
}
#main > * {
    padding-left: 10px;
    box-sizing: border-box;
    /* prevent flexbox centering overflow issue */
    margin: 0 auto;
}

/* -- title -- */
.title {
    font-size: 20px;
    text-transform: uppercase;
    text-shadow: 1px 1px 0px #0002;
    font-weight: bold;
    display: block;
    color: #393939;
    text-wrap: nowrap;
    overflow: hidden;
    text-align: center;
    padding-right: 10px;
    width: 100%;
}
.title > * {
    vertical-align: middle;
}
.title svg {
    height: 25px;
    width: 25px;
    min-width: 25px;
    min-height: 25px;
    margin-right: 5px;
}

/* -- footer -- */
.footer {
    font-size: 11px;
    opacity: .5;
    text-align: center;
    line-height: 120%;
}

/* -- conf+info box -- */
.scroller {
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow-x: auto;
    width: 100%;
    padding-bottom: 5px;
}

/* -- conf -- */
.conf {
    margin: 10px auto;
    margin-bottom: 5px;
    font-size: 90%;
    display: flex;
    flex-wrap: nowrap;
    justify-content: center;
    align-items: baseline;
    user-select: none;
}
.conf-block {
    display: block;
    padding: 0 6px;
    text-wrap: nowrap;
    border-left: 1px solid rgba(0, 0, 0, 0.271);
}
.conf-block .conf-title {
    text-transform: uppercase;
    font-weight: bold;
    color: #777;
    letter-spacing: 1px;
    font-size: 80%;
    margin-bottom: 1px;
}
.conf-block:first-child {
    padding-left: 0;
    border-left: none;
}
.conf-block .conf-viewmode {
    text-wrap: wrap;
}
.sorting-reversed,
.conf #sortingColumn {
    display: none;
}
.conf input[type='checkbox'] {
    vertical-align: bottom;
}
.conf label:first-of-type input[type='checkbox'] {
    margin-left: 0;
}

/* -- info line -- */
.info, .warnings {
    font-size: 80%;
    opacity: 50%;
    text-wrap: nowrap;
    margin: 0 auto;
}
.info a {
    color: black;
    text-decoration: dotted;
}
.info a:hover {
    text-decoration: underline;
}
.warnings > *:last-child::after {
    content: '┊';
    opacity: 0;
}
.warnings > * {
    color: #871818;
}
.info .trigger-info,
.warnings .trigger-info {
    background: none;
    border: none;
    padding: 0;
    font: inherit;
    cursor: pointer;
}
.info .trigger-info:hover,
.warnings .trigger-info:hover {
    text-decoration: underline dotted;
}

/* -- info popup -- */
.info-popup {
    position: absolute;
    font-size: 90%;
    top: 10px;
    left: 10px;
    margin-right: 10px;
    z-index: 500;
    background-color: white;
    font-size: 90%;
    padding: 20px;
    max-width: 600px;
    box-shadow: 6px 6px #0004, 0 0 0 1px #0001;
}
.info-popup ul {
    margin: 0;
    padding-left: 15px;
}
.info-popup > ul > li {
    margin-bottom: 3px;
}
#colorTips {
    font-weight: bold;
}
#infoPopupClose {
    position: absolute;
    top: 5px;
    right: 5px;
}
.info-popup .spoiler .clicker {
    cursor: pointer;
    padding: 0 5px;
    background-color: #0001;
}
.info-popup .spoiler .clicker::after {
    content: ' ▸';
}
.info-popup .spoiler.open .clicker::after {
    content: ' ▾';
}
.info-popup .spoiler.open .spoiler-body {
    display: inline;
}
.info-popup .spoiler .spoiler-body {
    display: none;
}


/* -- column titles -- */
.col-titles {
    display: flex;
    flex-wrap: nowrap;
    font-weight: bold;
    color: #5c5c5c;
    letter-spacing: 1px;
    font-size: 60%;
    gap: 10px;
    user-select: none;
    padding-top: 5px;
    padding-bottom: 3px;
    background-color: #fafafa;
    position: sticky;
    z-index: 400;
    top: 0;
}
.col-titles .col-title {
    text-align: right;
    text-transform: uppercase;
    width: 300px;
    margin: auto;
}
.col-titles .col-title span {
    cursor: pointer;
    margin-right: 10px;
    text-wrap: nowrap;
}
.col-titles .col-title.nm {
    width: 80px;
    cursor: default;
}
.col-titles .col-title.nm span {
    margin-right: 0;
}

.col-titles .col-title span:before {
    content: '▼ ';
    visibility: hidden;
    opacity: 80%;
}
.col-titles .col-title.active span:before {
    content: '▲ ';
}
.col-titles.inv .col-title.active span:before {
    content: '▼ ';
}
.col-titles .col-title.active span:before,
.col-titles.inv .col-title.active span:before {
    visibility: visible;
}
.col-titles .col-title span:hover:before {
    visibility: visible;
}

#selectColumn {
    display: none;
    box-shadow: 0 0 1px 0 gray;
    border-radius: 2px;
    padding: 0 4px;
    opacity: 70%;
    top: 0;
    position: absolute;
    left: 80px;
    text-transform: uppercase;
    height: 20px;
}

/* -- hero entries box -- */
#plots {
    margin-bottom: 200px;
    display: flex;
    flex-direction: column;
    flex-wrap: nowrap;
}

/* -- hero entries -- */
.entry {
    padding-bottom: 3px;
    margin-top: 3px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.271);
    height: 100px;
    display: flex;
    position: relative;
    column-gap: 10px;
}
.entry .hero-name {
    position: absolute;
    top: 0px;
    left: 0px;
    font-size: 80%;
    color: #0000;
}
.entry img {
    height: 80px;
    width: 80px;
    display: block;
    border-radius: 50%;
    align-self: center;
}
.entry .plot-parent {
    position: relative;
}
.entry .plot-parent.blink {
    background-color: #0001;
}

/* plots */
.entry .plot {
    height: 100px;
    width: 300px;
    display: none;
}
.entry .stub {
    height: 100px;
    width: 300px;
    display: none;
    position: absolute;
    top: 0;
    left: 0;
}
.plot svg.main-svg, .plot svg.main-svg * {
    /* allow xtick tooltip overflow */
    overflow: visible;
}
.plot svg .hovertext path {
    stroke-width: 0px !important;
}

/* bars */
.entry .bar {
    display: none;
    flex-direction: column;
    justify-content: center;
    width: 300px;
    height: 100px;
    font-size: 80%;
}
.entry .bar .tier {
    font-size: 90%;
    opacity: .5;
    position: absolute;
    top: 0;
    right: 0;
    display: none;
}
.entry .bar:hover .tier {
    display: block;
}
.entry .bar .total {
    width: fit-content;
}
.entry .bar .total.aleft::before,
.entry .bar .total.aright::after {
    font-size: 80%;
    vertical-align: top;
    opacity: .6;
}
.entry .bar .total.aleft::before {content: '◄';}
.entry .bar .total.aright::after {content: '►';}
.entry .bar .total {
    position: relative;
    opacity: .6;
}
.entry .bar .total.est .full:first-child::before {
    content: '~ ';
    opacity: .6;
}
.entry .bar .total .full {
    font-weight: bold;
}
.entry .bar .total .prefix {
    font-weight: bold;
    opacity: .6;
}
.entry .bar .total .frac {
    opacity: .6;
    font-weight: normal;
}
.entry .bar .nodata {
    opacity: .4;
}
.entry .bar .range {
    display: none;
    position: relative;
    font-size: 80%;
    opacity: .5;
}
.entry .bar:hover .range {
    display: block;
    position: absolute;
    bottom: 0;
    width: 100%;
}
.entry .bar .range div {
    position: absolute;
    bottom: 0;
}
.entry .bar .svg-box {
    position: relative;
    display: flex;
}
.entry .bar svg {
    display: block;
}
.entry .bar svg.cmp {
    opacity: .7;
}
.entry .bar svg.hover {
    display: none;
    position: absolute;
    user-select: none;
    pointer-events: none;
    top: 0;
    left: 0;
}
.entry .bar .svg-box:hover svg.hover {
    display: block;
    z-index: 500;
}

/* plane */
#plane {
    display: none;
    position: relative;
    aspect-ratio: 10/7;
    width: 90%;
    min-width: 600px;
    max-width: 1000px;
    flex-shrink: 0;
    padding: 0 40px 0 75px;
    margin-bottom: 100px;
}
#planeplot {
    flex-grow: 1;
}
#plane .border {
    height: 100%;
    top: 0;
    left: 75px;
    box-shadow: 0 0 3px #0000004c inset;
    z-index: -100;
    background-color: #f1f1f178;
    position: absolute;
}
#planeplot svg.main-svg, .plot svg.main-svg * {
    /* allow xtick tooltip overflow */
    overflow: visible;
}
.plane-conf {
    display: none;
    margin-top: 0;
    margin-bottom: 0 !important;
    color: #333;
    opacity: .7;
    transform: scale(.9);
}

/* stacked pr bar */
#stackedPRBar {
    width: 10px;
    height: 100%;
}
#stackedPRBar .bar {
    width: 100%;
    position: relative;
    box-shadow: 0 -1px 0 #fff6 inset;
}
#stackedPRBar .bar .tooltip {
    display: none;
    position: absolute;
    top: 0px;
    font-size: 80%;
    color: #666;
    right: 9px;
    background-color: #fff;
    text-wrap: nowrap;
    padding-left: 3px;
}
#stackedPRBar .bar:hover .tooltip {
    display: block;
}
#stackedPRBar .bar .tooltip .extra {
    display: inline-block;
    padding: 3px 5px;
}

/* viewmode conditional */
.viewmode-bars .entry .bar {display: flex;}
.viewmode-plots .entry .plot {display: block;}
.viewmode-plane #plots, .viewmode-plane .col-titles {display: none;}
.viewmode-plane #plane {display: flex;}
.viewmode-plane .plane-conf {display: flex;}

/* -- PC -- */
@media screen and (min-width: 700px) {
    /* cnExtra conditional */
    .plot-parent.extra, .col-title.extra, #selectColumn .extra {display: none;}
    .show-cn-extra .plot-parent.extra,
    .show-cn-extra .col-title.extra {
        display: block;
    }
    .show-cn-extra .plot-parent.base,
    .show-cn-extra .col-title.base {
        display: none;
    }
}

/* -- mobile -- */
@media screen and (max-width: 700px) {
    .conf {justify-content: left;}
    .title {font-size: 100%;}
    .entry img {height: 60px; width: 60px;}
    .col-titles .col-title.nm {width: 60px;}
    #selectColumn {display:inline-block;}
    .entry .stub {display: block;}
    .viewmode-plots .entry .stub {display: block;}
    .viewmode-bars .entry .stub {display: none;}
    .mobile-focused .stub {display: none !important;}
    .mobile-focused .plot {box-shadow: -5px 0 0 #0004;}
    .col-titles {
        height: 20px;
        font-size: 80%;
        padding: 3px 0;
    }

    /* cnExtra conditional */
    .show-cn-extra #selectColumn .base {display: none;}
    .show-cn-extra #selectColumn .extra {display: block;}
    #selectColumn .extra {display: none;}

    /* selectColumn conditional */
    .plot-parent.pr, .plot-parent.wr, .plot-parent.br, .plot-parent.kd,
    .col-title.wr, .col-title.pr, .col-title.br, .col-title.kd {display: none;}
    .mobile-show-pr .plot-parent.pr {display: block;}
    .mobile-show-pr .col-title.pr {display: block;}
    .mobile-show-wr .plot-parent.wr {display: block;}
    .mobile-show-wr .col-title.wr {display: block;}
    .mobile-show-kd .plot-parent.kd {display: block;}
    .mobile-show-kd .col-title.kd {display: block;}
    .mobile-show-br .plot-parent.br {display: block;}
    .mobile-show-br .col-title.br {display: block;}
}

@keyframes flash {
    0%   {background-color: transparent;}
    50%  {background-color: rgba(74, 210, 255, 0.5);}
    100% {background-color: transparent;}
}
</style>
</head>
<body>

<div class='info-popup hidden'>
    <button id='infoPopupClose'>x</button>
    <ul>
        <li>Line colors: <span id='colorTips'></span>.</li>

        <li><b>Hover</b> (or click on mobile) on any plot to see exact values and legend at near position.</li>

        <li><b>Double click</b> any plot to zoom in/out (toggle relative scale). Hold Ctrl to include zeroline.</li>

        <li>Starting "<b>All</b>" values represent Competitive total values across all tiers (Curves-view).</li>

        <li><b>Dashed</b> lines represens "expected" value.<ul>
            <li>For winrate it's 50%.</li>
            <li>For pickrate it's the value if every hero was picked equally often within their role.</li>
            <li>(CN) For banrate it's the value if every hero was banned equally often.</li>
            <li>(CN) For KDA it's mean value for the role (calculated by this page).</li>
        </ul></li>

        <li>Special <b>sorting</b> modes:<ul>
            <li>B / M Diff. – difference between Bronze and Master (slope of the facet line).</li>
            <li>Facet Diff. – variance between facet lines (calculated as MAD from mean line).
                In Bars-view only currently shown tier is considered ("All" or last sorted-by tier).</li>
        </ul></li>

        <li><b>*Average</b> (mean) values are computed by this page (Blizzard does not provide it).
        Since we do not know population sizes (weights) – our mean is only an estimate of true mean.</li>

        <li class='spoiler'><span class='clicker'><b>Chinese</b> data</span><span class='spoiler-body'>
            comes from a <a href='https://ow.blizzard.cn/herolist/'>separate official source</a>.
            I do not know if the numbers are calculated in the exact same manner as on the main site.<ul>
            <li>There is no PC/Console separation (is it even available on Consoles there).</li>
            <li>It provides QP data broken down by ranks (huh!), so you can also facet by Game Mode.</li>
            <li>It provides independant Champ data (main site bundles it with GM), this page ignores it.</li>
            <li>Pickrate/banrate numbers are scaled to conform to main website convention.</li>
        </ul></span></li>

        <li class='spoiler'><span class='clicker'>Extra <b>view</b>-modes</span><span class='spoiler-body'><ul>
            <li>Bars-view: like the official page but with more points on the bar for easier comparisons.<ul>
                <li>The min-max shown is absolute (e.g. 40-60 for winrates) instead of relative to the data.</li>
                <li>For anything other than comparing QP to Comp, prefer Curves-view.</li>
            </ul></li>
            <li>Plane-view: WR/PR on an xy-plane.<ul>
                <li>Includes pickrates stacked bar to visualize pick proportions.</li>
            </ul></li>
            <li>Use sorting controls to select specific rank or primary facet (for Plane-view).</li>
        </ul></span></li>

        <li class='spoiler'><span class='clicker'><b>Dataset</b> & about</span><span class='spoiler-body'><ul>
            <li>This is a static page with no own backing server. <a href='https://github.com/hermit-crab/ow-winrates-faceted'>GitHub</a>.</li>
            <li>Currently loaded dataset file is located <a id='datasetLink' href=''>here</a>.
                Includes CN data. Does not include any map specific data, but otherwise it should be same complete data from official source.
            </li>
            <li>Corresponding global variable: <code>rawData</code></li>
            <li>Nicer post-processed long form variable: <code>allEntries</code></li>
        </ul></span></li>

        <li class='spoiler' id='archiveInfo' style='display:none'><span class='clicker'><b>Archive</b></span><span class='spoiler-body'><ul>
        </ul></span></li>

    </ul>
</div>

<div id='main' class='mobile-show-wr viewmode-plots'>

<div class='title'>
    <svg xmlns='http://www.w3.org/2000/svg' fill='none' aria-labelledby='blz-icon-title-overwatch-2-dark' viewBox='0 0 48 48' part='icon'><title id='blz-icon-title-overwatch-2-dark'>Overwatch 2</title><path fill='#ED6516' d='M13.9 13.901a14.284 14.284 0 0 1 20.2 0l4.043-4.042a20 20 0 0 0-28.286 0z'></path><path fill='#333E48' d='m39.312 11.135-4.063 4.062a14.29 14.29 0 0 1 .995 16.159L28.891 24l-4.006-9.413h-.02V27.31l7.938 7.938a14.29 14.29 0 0 1-17.606 0l7.939-7.938V14.636l-4.027 9.365-7.355 7.355a14.29 14.29 0 0 1 .997-16.159l-4.063-4.062a20.001 20.001 0 1 0 30.624 0'></path></svg>
    <span>Overwatch 2 Winrates & Pickrates – Faceted</span>
</div>

<div class='scroller'>
<div class='conf'>
    <div class='conf-block conf-viewmode'>
        <div class='conf-title'>View</div>
        <select id='viewMode'>
            <option value='plots' selected>Curves</option>
            <option value='bars'>Bars</option>
            <option value='plane'>Plane</option>
        </select>
    </div>
    <div class='conf-block facet-block'>
        <div class='conf-title'>Facet</div>
        <select id='facet'>
            <option value='region' selected>Region</option>
            <option value='input'>Platform</option>
            <option value='mode'>Mode</option>
            <option value='tier'>Rank</option>
        </select>
    </div>
    <div class='conf-block'>
        <div class='conf-title'>Select</div>
        <select id='filterRole'>
            <option value='all' selected>Role</option>
            <option class='fillRoles'>...replaced via JS</option>
        </select>
        <select id='filterRegion'>
            <option value='all' selected>Region</option>
            <option class='fillRegions'>...replaced via JS</option>
            <option value='mean'>*Average</option>
        </select>
        <select id='filterPlatform'>
            <option class='fillPlatforms'>...replaced via JS</option>
        </select>
    </div>
    <div class='conf-block'>
        <div class='conf-title'>China</div>
        <label>
            <input type='checkbox' id='chinaOn'></input>On
        </label>
        <label title='Show KDA/Banrates'>
            <input type='checkbox' id='cnExtra'></input>More
        </label>
    </div>
    <div class='conf-block'>
        <div class='conf-title'>Sort mode</div>
        <select id='sortingMode'>
            <option value='all' selected>All Ranks</option>
            <option class='fillTiers'>...replaced via JS</option>
            <option value='b-m-delta'>B / M Diff.</option>
            <option value='facets-spread'>Facet Diff.</option>
        </select>
        <select id='sortingRegion'>
            <option class='fillRegions'>...replaced via JS</option>
            <option value='mean'>*Average</option>
        </select>
        <select id='sortingPlatform'>
            <option class='fillPlatforms'>...replaced via JS</option>
        </select>
        <select id='sortingGameMode'>
            <option class='fillModes'>...replaced via JS</option>
        </select>
        <select id='sortingTier'>
            <option class='fillTiers'>...replaced via JS</option>
        </select>
        <select id='sortingColumn'>
            <option value='name'>Name</option>
            <option value='winrate' selected>Winrate</option>
            <option value='pickrate'>Pickrate</option>
            <option value='banrate'>Banrate</option>
            <option value='kda'>KDA</option>
        </select>
        <label class='sorting-reversed'>
            <input type='checkbox' id='sortingReverse' checked></input>Reversed
        </label>
    </div>
</div>

<div class='info'>
    <button class='trigger-info'>legend and info ★</button> ┊
    data refreshed: <span id='datasetTs'></span> ┊
    <a href='https://overwatch.blizzard.com/en-us/rates/'>official source</a> ┊
    <a href='https://docs.google.com/forms/d/e/1FAIpQLSd8aEzuAdIPjHKv_0VND6HbKdywIi7SWBeIFV2k1t_3bvHaIw/viewform?usp=dialog'>report issue</a>
</div>
<div class='warnings hidden'></div>
</div>

<div class='col-titles'>
    <div class='col-title nm' data-sort='name'><span>Hero</span></div>
    <div class='col-title wr base active' data-sort='winrate'><span>Winrate</span></div>
    <div class='col-title pr base' data-sort='pickrate'><span>Pickrate</span></div>
    <div class='col-title kd extra' data-sort='kda'><span>KDA</span></div>
    <div class='col-title br extra' data-sort='banrate'><span>Banrate</span></div>
    <select id='selectColumn'>
        <option class='base' value='wr' selected>Winrate</option>
        <option class='base' value='pr'>Pickrate</option>
        <option class='extra' value='kd'>KDA</option>
        <option class='extra' value='br'>Banrate</option>
    </select>
</div>
<div id='plots'>Loading...</div>

<div class='conf plane-conf'>
    <div class='conf-block'>
        <div class='checkboxes' id='selectedRegions'>
            <checkbox class='fillRegions'>...replaced via JS</checkbox>
            <label><input type='checkbox' value='mean'/>*Avarage</label>
        </div>
        <div class='checkboxes' id='selectedPlatforms'><checkbox class='fillPlatforms'>...replaced via JS</checkbox></div>
        <div class='checkboxes' id='selectedGameModes'><checkbox class='fillModes'>...replaced via JS</checkbox></div>
        <div class='checkboxes' id='selectedTiers'><checkbox class='fillTiers'>...replaced via JS</checkbox></div>
    </div>
    <div class='conf-block'>
        <label><input id='planeMarkerColor' type='checkbox'/>Dot Color</label>
        <label><input id='planeZoomPr' type='checkbox' checked/>Zoom PR</label>
    </div>
</div>
<div id='plane'><div class='border'></div><div id='planeplot'>Loading...</div><div id='stackedPRBar'></div></div>

</div>

<div class='footer'>
This page is not affiliated with Overwatch or Blizzard Entertainment.<br/>
Overwatch is a trademark of Blizzard Entertainment, Inc., in the U.S. and/or other countries.
</div>

<script>
'use strict';

const TIERS = ['Bronze', 'Silver', 'Gold', 'Platinum', 'Diamond', 'Master', 'Grandmaster'];
// const SD_TIERS = ['Rookie', 'Novice', 'Contender', 'Elite', 'Pro', 'AllStar', 'Legend'];
const TIER_COLORS = ['#cd7850', '#c4c6c8', '#d8a43d', '#98d8b9', '#5f9ff0', '#8ae960', '#8d71fe'];
const REGIONS = ['Americas', 'Europe', 'Asia', 'China'];
const REGION_COLORS = ['#f14141', '#3c90ff', '#ffac00', '#58d986'];
const PLATFORMS = ['PC', 'Console'];
const GAMEMODES = ['Comp', 'QP'];
const EXTRA_COLORS = {
    Console: '#999', QP: '#afafa5ff',
    mercy: '#beb144', zenyatta: '#e2d008',
    mean: 'black', allTiers: 'black'
};
const ROLES = ['support', 'tank', 'damage'];
const DATASET_FPATH = 'winrate-data.js';
const ARCHIVE_FPATH = 'archive/owwr/archive-info.js'; // does not need to exist
const EXTERNAL_FPATH_BASE = 'https://hermit-crab.neocities.org/';
const ALL_TIER_IDX = -.5;
const ALT_NAMES = {'PC': 'KB&M', 'mean': '*Average', 'Grandmaster': 'GM+'};
const VALTYPES = ['name', 'winrate', 'pickrate', 'kda', 'banrate'];
const VALTYPES_SHORT = ['nm', 'wr', 'pr', 'kd', 'br'];
const WARNINGS = {
    cn: 'see notes about CN data',
    avg: 'synthetic unweighted *Average',
    planekda: 'Not supported in Plane-view.',
};

const UI = Object.fromEntries([...document.querySelectorAll('*[id]')].map(e => [e.id, e]));
const CMAP = Object.fromEntries([
    ...TIERS.map((k, i) => [k, TIER_COLORS[i]]),
    ...REGIONS.map((k, i) => [k, REGION_COLORS[i]]),
    ...Object.entries(EXTRA_COLORS),
]);
const zeroline = {
    type: 'line', x0: -1, x1: 10, y0: 0, y1: 0,
    line: {color: '#0007', width: .5, dash: ''}, layer: 'between',
};
const layoutConf = {
    winrate: {
        yrange: {general: [41, 59]},
        bar: {general: [40, 60]},
    },
    pickrate: {
        yrange: {general: [-1, 40], tank: [-1, 20]}, guideline: zeroline,
        bar: {general: [0, 40], tank: [0, 20]},
    },
    banrate: {
        yrange: {general: [-1, 30]}, guideline: zeroline,
        bar: {general: [0, 90]},
        high: {yrange: [-1, 100], dtick: 30},
    },
    kda: {
        yrange: {general: [1, 6]}, guideline: zeroline,
        bar: {general: [1.5, 6], damage: [1.5, 4]},
    },
};
let rawData, heroes, allEntries, regionMeans, regionMeansWithCN, confHandler,
    pressedKeys = new Set(), expectedBase = {};


function setup() {
    if (window.matchMedia('(max-width: 700px)').matches)
        UI.viewMode.value = 'bars';

    confHandler = new ConfHandler();
    setupEventHandlers();
    setupColorTips();
    loadArchiveInfo(localStorage.uselocal ? ARCHIVE_FPATH : EXTERNAL_FPATH_BASE + ARCHIVE_FPATH);

    let datasetUrl = localStorage.uselocal ? DATASET_FPATH : EXTERNAL_FPATH_BASE + DATASET_FPATH;
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('dataset'))
        datasetUrl = datasetUrl.replace('winrate-data', urlParams.get('dataset'));
    UI.datasetLink.href = datasetUrl;
    loadData(datasetUrl);
}


function loadJonp(jsonpSrc, errorCb) {
    const script = document.createElement('script');
    script.type = 'text/javascript';
    // allow retrieval from cache only within an hour
    script.src = jsonpSrc + '?nocache=' + parseInt(Date.now()/1000/60/60);
    if (errorCb)
        script.addEventListener('error', errorCb);
    document.body.appendChild(script);
}


function loadData(jsonpSrc) {
    loadJonp(jsonpSrc, () => {
        UI.plots.innerHTML = UI.planeplot.innerHTML = `Failed loading data from ${jsonpSrc}.`;
    });
}


function jsonp(data) {
    if (data.type === 'archive-info') receiveArchiveInfo(data.html);
    else receiveRawData(data);
}


function receiveRawData(data) {
    rawData = data;
    [heroes, allEntries] = processRawData(rawData);
    regionMeans = computeRegionMeans(allEntries.filter(e => e.region !== 'China'));
    regionMeansWithCN = computeRegionMeans(allEntries);
    expectedBase.pr = Object.fromEntries(ROLES.map(role =>
        [role, (role === 'tank' ? 100 : 200) / Object.values(heroes).filter(h => h.role === role).length]
    ));
    expectedBase.br = 400 / Object.keys(heroes).length;
    const dataTs = rawData[0]._ts;
    UI.datasetTs.innerHTML = moment(dataTs * 1000).fromNow();
    UI.datasetTs.title = moment(dataTs * 1000).toString();
    UI.planeplot.innerHTML = '';
    renderHeroes();
    render();
}


function processRawData(rawData) {
    const mainData = rawData.filter(o => o._url.includes('blizzard.com'));
    const cnData = rawData.filter(o => o._url.includes('blizzard.cn'));
    const rows = [];

    const select = (o, keys) => Object.fromEntries(keys.map(k => [k, o[k]]));
    const pct1f = (v) => Math.round(v*1000)/10;

    // NOTE: On main site pickrates data sum up to 500% [sum(tank)=100 + sum(support)=200 + sum(damage)=200]
    // in CN data it is all normalized to sum up to 100%. We stick to main site convention so
    // CN data will be rescaled to same proportions and total.

    // NOTE: Main site (blog) presented the banrates with a view that sums up to 400%.
    // https://overwatch.blizzard.com/en-us/news/24205940/weekly-recall-hero-bans/
    // CN data has it sum up to 100, we rescale it to follow main site convention.

    // NOTE: Main site data bundles GM+Champ together, CN data gives Champ as is. We ignore it.

    const rqCodes = [...new Set(mainData.map(a => a.selected.rq))];
    rqCodes.sort();
    if (rqCodes.length !== 2)
        console.error('unexpected amount of rqCodes (expected 2)', rqCodes);
    let modes = Object.fromEntries([['0', 'QP'], [rqCodes.at(-1), 'Comp']]);
    for (const facet of mainData) {
        for (const entry of facet['rates'])
            rows.push({
                hero: entry.id,
                mode: modes[facet.selected.rq],
                url: facet._url,
                banrate: -1,
                kda: -1,
                ...select(entry.cells, ['winrate', 'pickrate']),
                ...select(facet.selected, ['map', 'input', 'region', 'tier']),
            });
    }

    const heroes = Object.fromEntries(mainData[0]['rates'].map(e =>
        [e.id, {
            name: e.hero.name,
            role: e.hero.role.toLowerCase(),
            color: '#' + e.hero.color.slice(0, 6),
            iconUrl: e.hero.portrait,
            roleIconUrl: e.hero.roleIcon,
        }]
    ));

    // const sd2comp = Object.fromEntries(TIERS.map((t, i) => [SD_TIERS[i], t]));
    modes = {kuaisu: 'QP', jingji: 'Comp', juedou: 'Stadium'};
    for (const facet of cnData) {
        const selected = Object.fromEntries(new URL(facet._url).searchParams);
        const rolesTotalPR = Object.fromEntries(ROLES.map(r => [r, facet.data.filter(
            e => heroes[e.hero_id].role === r
        ).map(e => e.selection_ratio).reduce(sum, 0)]));
        for (const entry of facet['data']) {
            if (selected.mmr === 'Champion') continue;
            if (modes[selected.game_mode] === 'Stadium') continue;
            let tier = selected.mmr === '-127' ? 'All' : selected.mmr;
            const role = heroes[entry.hero_id].role;
            const roleSlots = role === 'tank' ? 1 : 2;
            rows.push({
                hero: entry.hero_id,
                url: facet._url,
                winrate: entry.win_ratio,
                pickrate: pct1f((entry.selection_ratio / rolesTotalPR[role]) * roleSlots),
                banrate: entry.ban_ratio * 4,
                kda: entry.kda,
                mode: modes[selected.game_mode],
                // tier: sd2comp[tier] || tier,
                tier: tier,
                map: 'all-maps', input: 'PC', region: 'China'
            });
        }
    }

    return [heroes, rows];
}


function renderHeroes() {
    UI.plots.innerHTML = '';
    Object.entries(heroes).forEach(([id, hero]) => {
        const main = document.createElement('div');
        main.className = `entry role-${hero.role}`;
        main.innerHTML = `
        <div class='hero-name' title='${hero.name}'>${hero.name}</div>
        <img src='${hero.iconUrl}' title='${hero.name}'>
        ${VALTYPES_SHORT.slice(1).map(
            k => `
            <div class='plot-parent ${k} ${['wr', 'pr'].includes(k) ? 'base' : 'extra'}'>
                <div class='plot'></div>
                <div class='stub'></div>
                <div class='bar'></div>
            </div>
            `
        ).join('')}`;
        // We add invisible overlays (stubs) to prevent plot from stealing mobile drag-scroll.
        // We hide that overlay on click.
        main.querySelectorAll('.stub').forEach(
            elem => elem.addEventListener('click', evt => mobileFocusPlot(elem.parentElement, true, evt))
        );
        UI.plots.appendChild(main);
        hero.elems = Object.fromEntries(VALTYPES_SHORT.slice(1).map(
            v => [VALTYPES[VALTYPES_SHORT.indexOf(v)], {
                plot: main.querySelector(`.plot-parent.${v} .plot`),
                bar: main.querySelector(`.plot-parent.${v} .bar`),
            }]
        ))
        hero.elems.main = main;
    });
}


function render() {
    const conf = confHandler.frozenConf();
    let entries = [...allEntries, ...(conf.chinaOn ? regionMeansWithCN : regionMeans)];

    // ==> Filter entries
    entries = entries.filter(e => (
        e.map === 'all-maps' &&
        (e.mode === 'Comp' || conf.facet === 'mode') &&
        (e.input === conf.filterPlatform || conf.facet === 'input') &&
        (e.region === conf.filterRegion || ['all', 'mean'].includes(conf.filterRegion)) &&
        (e.region !== 'China' || conf.chinaOn)
    ));
    if (conf.filterRegion === 'mean' && conf.facet !== 'region')
        entries = entries.filter(e => e.region === conf.filterRegion);

    // (calc KDA guideline)
    let expectedKd = {};
    if (conf.cnExtra) expectedKd = Object.fromEntries(ROLES.map(role => {
        const vals = entries.filter(
            e => heroes[e.hero].role === role && e.tier === 'All' && e.kda !== -1
        ).map(e => e.kda);
        return [role, vals.reduce(sum, 0) / vals.length];
    }));

    // ==> Sort heroes
    let names = Object.keys(heroes);
    // names = names.filter(n => n.includes('rein'));
    if (conf.filterRole !== 'all') names = names.filter(name => heroes[name].role === conf.filterRole);
    const name2entries = Object.fromEntries(names.map(n => [n, entries.filter(e => e.hero === n)]));
    names.sort(); // sort alphabetically by default
    if (conf.sortingColumn !== 'name') {
        const dummy = Object.fromEntries(VALTYPES.map(k => [k, -2]));
        const c = conf.sortingColumn;
        names = sortBy(names, name => {
            let entries = name2entries[name].filter(e => e[c] !== -1);
            if (conf.sortingMode !== 'facets-spread')
                entries = entries.filter(e => e[conf.facet] === conf.sortFacetValue);
            else if (['mean', 'all'].includes(conf.filterRegion) && conf.facet === 'region')
                entries = entries.filter(e => e.region !== 'mean');
            let byTier = Object.fromEntries(TIERS.map(t => [t, entries.filter(e => e.tier === t)]));
            if (conf.viewMode === 'bars')
                byTier = {[conf.lastTier]: entries.filter(e => e.tier === conf.lastTier)};
            if (conf.sortingMode === 'facets-spread')
                return calcMAD(Object.values(byTier).map(lst => pluck(lst, c)));
            Object.entries(byTier).forEach(([k, v]) => {byTier[k] = v[0] || dummy;}); // fill missing data
            const eAll = entries.filter(e => e.tier === 'All')[0] || dummy;
            if (conf.sortingMode === 'all') return eAll[c];
            if (conf.sortingMode === 'b-m-delta') return byTier.Master[c] - byTier.Bronze[c];
            if (conf.sortingMode.startsWith('tier-')) return byTier[conf.sortingMode.slice(5)][c];
        });
    }
    if (conf.sortingReverse) names.reverse();
    Object.entries(heroes).forEach(([name, hero]) => {
        hero.elems.main.classList.toggle('hidden', !names.includes(name));
        hero.elems.main.style.order = names.indexOf(name);
    });

    // (render plane plot and exit)
    if (conf.viewMode === 'plane') {
        renderPlanePlot(name2entries, conf);
        renderStackedPRBar(name2entries, conf);
        return;
    }

    // ==> Update plots
    const viewKey = [conf.facet, conf.filterRegion, conf.filterPlatform, conf.chinaOn, conf.cnExtra].join(',');
    names.forEach((name, idx) => {
        const hero = heroes[name];
        hero.elems.main.style.zIndex = names.length - idx; // fixes xtick tooltip clipping
        const cols = !conf.cnExtra ? ['winrate', 'pickrate'] : ['kda', 'banrate'];
        const expected = {
            winrate: 50, pickrate: expectedBase.pr[hero.role],
            kda: expectedKd[hero.role], banrate: expectedBase.br,
        };
        if (conf.viewMode === 'bars') {
            cols.forEach(valtype => renderBar(hero, name2entries[name], valtype, expected[valtype], conf));
            return;
        }
        if (hero.viewKey === viewKey) return;
        clearTimeout(hero.renderTimeout);
        hero.renderTimeout = setTimeout(_ => {
            // Schedule updates one after another with a minor delay for better UX.
            // (doing all in one go takes .8-1s of stagger, yes I should switch to d3 or charts.js)
            hero.viewKey = viewKey;
            cols.forEach(valtype => renderTieredPlot(hero, name2entries[name], valtype, expected[valtype], conf));
        }, 30 * idx);
    });
}


function renderBar(hero, entries, valtype, expected, conf) {
    entries = entries.filter(e => e.tier === conf.lastTier && e[valtype] !== -1);
    const [a, b] = layoutConf[valtype].bar[conf.filterRole] || layoutConf[valtype].bar.general;
    const [w, h] = [300, 30];
    const bar = hero.elems[valtype].bar;
    const s = x => (x-a)/(b-a)*w; // scaler
    entries = entries.map(e => ({
        ...e, x: e[valtype],
        clr: conf.facetCmap[e[conf.facet]],
    })).filter(e => e.clr);
    if (!entries.length) {
        bar.innerHTML = '<div class="nodata">no data</div>';
        return;
    }
    const facetValues = pluck(entries, conf.facet);
    if (facetValues.length != new Set(facetValues).size)
        throw new Error('multiple values of the same facet after filter');
    const vals = entries.map(e => e.x);
    let [min, max] = [Math.min(...vals), Math.max(...vals)];
    const [smin, smax] = [s(min), s(max)];
    const baseW = clamp(smin, 0);
    const tailW = clamp(w - smax, 0);
    const pad = 5;
    const barh = h - pad*2;
    const th = 12;
    const tooltips = entries.filter(
        e => !conf.regionMeanView || e[conf.facet] !== 'mean'
    ).map((e, i) => {
        const name = ALT_NAMES[e[conf.facet]] || e[conf.facet];
        const [texta, textb] = [`${name}`, `${e.x}`];
        const [twa, twb] = [texta.length * 7, textb.length * 7];
        let x = clamp(s(e.x), 0, w);
        const padR = 2;
        let [rectxa, rectxb]  = [x-twa-padR*2, x];
        const [offA, offB] = [8, (Math.floor(i / 2) % 2)*(th+padR*2)];
        let y = -offB - offA - padR + pad;
        let [l1, l2] = [y, pad];
        if (i%2) {
            y = -y + th + barh + pad;
            [l1, l2] = [y-th, pad+barh];
        }
        return [
        `<line x1='${x}' y1='${l1}' x2='${x}' y2='${l2}' stroke='${e.clr}' stroke-width='2' stroke-linecap='butt'
            vector-effect='non-scaling-stroke'/>
        `,`
        <rect x='${rectxa}' y='${y-th}' width='${twa+padR*2}' height='${th+padR*2}' fill='${e.clr}'/>
        <rect x='${rectxa}' y='${y-th}' width='${twa+padR*2}' height='${th+padR*2}' fill='#fff5'/>
        <rect x='${rectxb}' y='${y-th}' width='${twb+padR*2+2}' height='${th+padR*2}' fill='${e.clr}'/>
        <rect x='${rectxb}' y='${y-th}' width='${twb+padR*2+2}' height='${th+padR*2}' fill='#fffc'/>
        `,`
        <text x='${rectxa+padR}' y='${y}' font-size='${th}' fill='black' textLength='${twa}'
            text-anchor='start' dominant-baseline='text-top'>${texta}</text>
        <text x='${rectxb+padR+2}' y='${y}' font-size='${th}' fill='black' textLength='${twb}'
            text-anchor='start' dominant-baseline='text-top'>${textb}</text>
        `,
        ];
    });
    if (conf.regionMeanView)
        min = max = entries.filter(e => e[conf.facet] === 'mean')[0]?.x || -1;
    const [minA, minB, maxA, maxB] = [min, max].flatMap(v => v.toFixed(1).split('.'));
    const classes = [
        (min < a ? 'aleft ' : ''), (max > b ? 'aright' : ''),
        (conf.filterRegion === 'mean' ? 'est' : '')
    ].join(' ');
    const offset = clamp(s(min), 0, w);
    const tierBg = conf.lastTier !== 'All' ? CMAP[conf.lastTier] + '99' : 'unset';
    bar.innerHTML = `
        <div class='tier'>Rank: <span style='background-color:${tierBg};'>
            ${ALT_NAMES[conf.lastTier] || conf.lastTier}
        </span></div>
        <div class='total ${classes}' style='left:${offset}px;'>
            <span class='full'>${minA}</span><span class='frac'>.${minB}</span>
            ${min === max ? '' : `
                – <span class='full'>${maxA}</span><span class='frac'>.${maxB}</span>
            `}
        </div>
        <div class='svg-box'>
        <svg width='${w}' height='${h}' overflow='hidden'>
            <rect x='0' y='${pad}' width='${baseW}' height='${barh}' fill='rgba(0,0,0,0.35)'/>
            <rect x='${smin}' y='${pad}' width='${smax - smin}' height='${barh}' fill='rgba(0,0,0,0.2)'/>
            ${entries.map((e) => `
                <line x1='${s(e.x)}' y1='${pad}' x2='${s(e.x)}' y2='${pad+barh}'
                stroke='${e.clr}' stroke-width='2' stroke-linecap='butt'
                vector-effect='non-scaling-stroke'/>
            `).join('')}
            <line x1='${s(expected)}' y1='0' x2='${s(expected)}' y2='${h}' stroke='black' stroke-width='1'
                vector-effect='non-scaling-stroke' stroke-dasharray='2,2' stroke-linecap='round'/>
            <rect x='${smax}' y='${pad}' width='${tailW}' height='${barh}' fill='rgba(0,0,0,0.05)'/>
        </svg>
        <svg class='hover' width='${w}' height='${h}' overflow='visible'>
            ${[0,1,2].flatMap(i => tooltips.map(layers => layers[i])).join('')}
        </svg>
        </div>
        <div class='range'><div style="left:0px;">${a}</div><div style="right:0px;">${b}</div></div>
    `;
    setTimeout(_ => {
        const elem = bar.querySelector('.total');
        const bbox = elem.getBoundingClientRect();
        if (bbox.right > elem.parentElement.getBoundingClientRect().right)
            elem.style.left = `${w - bbox.width}px`;
    }, 0);
}


function renderTieredPlot(hero, entries, valtype, expected, conf) {
    // Line traces
    const traces = conf.facetValues.map(facetValue => {
        const facetEntries = entries.filter(e => (
            e[conf.facet] === facetValue && e[valtype] !== -1
        ));

        // Insert total points at the end.
        // Dud in front breaks the line so All is disconnected from GM.
        const points = [...TIERS, null, 'All'].map((t, idx) => {
            if (!t) return {x: TIERS.length-1};
            let entry = facetEntries.filter(e => e.tier === t);
            if (entry.length > 1) throw new Error('unexpected multiple entries after filter');
            entry = entry[0];
            if (!entry) return;
            if (t === 'All')
                return {x: ALL_TIER_IDX, y: entry[valtype], symbol: 'arrow-left', size: 6};
            return {x: idx, y: entry[valtype], symbol: 'circle', size: 4};
        }).filter(e => e);
        if (points.length === 1) return;

        let extraAttrs = {};
        let size = pluck(points, 'size');
        if (conf.regionMeanView && facetValue !== 'mean') {
            extraAttrs = {hoverinfo: 'skip', opacity: .45};
            size = [...size.slice(0, -1).map(_ => 0), size.at(-1)];
        }

        return {
            x: pluck(points, 'x'), y: pluck(points, 'y'),
            name: `<b>${ALT_NAMES[facetValue] || facetValue}</b>`,
            mode: 'lines+markers',
            line: {color: conf.facetCmap[facetValue], width: 1.2},
            marker: {size: size, symbol: pluck(points, 'symbol'), line: {width: 0}, opacity: 1},
            ...extraAttrs,
        };
    }).filter(t => t);

    const shapes = [];
    if (layoutConf[valtype].guideline)
        shapes.push(layoutConf[valtype].guideline)
    if (expected != null)
        shapes.push({
            type: 'line', x0: -1, x1: 10, y0: expected, y1: expected,
            line: {color: 'black', width: .5, dash: 'dot'}, layer: 'between',
        });

    let yrange = layoutConf[valtype].yrange[hero.role] || layoutConf[valtype].yrange.general;
    let dtick, annotations = [];
    if (valtype === 'banrate') {
        const maxAll = Math.max(...entries.filter(e => e.tier === 'All').map(e => e.banrate));
        if (maxAll > expected) {
            yrange = layoutConf.banrate.high.yrange;
            dtick = layoutConf.banrate.high.dtick;
            annotations.push({
                xref: 'paper', yref: 'paper', x: 1, y: 1, text: 'zoomed out', opacity: .45, showarrow: false
            });
        }
    }

    const plot = hero.elems[valtype].plot;
    Plotly.react(plot, traces, {
        margin: { l: 20, r: 0, t: 0, b: 15 },
        showlegend: false,
        plot_bgcolor: '#0000',
        paper_bgcolor: '#0000',
        hovermode: 'x',
        hoverlabel: {font: {size: 12}},
        dragmode: 'pan',
        xaxis: {
            range: [ALL_TIER_IDX, TIERS.length-1+.3],
            fixedrange: true,
            zeroline: false,
            tickvals: [...TIERS.map((_, idx) => idx), ALL_TIER_IDX],
            ticktext: [
                ...TIERS.map((t, i) => `<span style='color: ${CMAP[t]}; font-weight: bold'>${ALT_NAMES[t] || t[0]}</span>`),
                `<span style='color:#fafafa;'>All</span>`
            ],
            tickfont: {size: 9},
        },
        yaxis: {
            zeroline: false,
            tickfont: {size: 10, color: '#0009'},
            ticklabelstandoff: 4,
            range: yrange.slice(),
            dtick: dtick,
        },
       shapes: shapes, annotations: annotations,
    }, {displayModeBar: false, responsive: true, scrollZoom: false, doubleClick: false});
    plot._defaultYrange = yrange.slice();
    plot.removeAllListeners('plotly_doubleclick');
    plot.on('plotly_doubleclick', () => plotToggleZoom(plot));
}


function renderPlanePlot(name2entries, conf) {
    const [xrange, yrange] = [[40, 60], [0, conf.planeZoomPr ? 2.3 : 3.1]];
    const [xl, yl] = [(xrange[1]-xrange[0]), (yrange[1]-yrange[0])];
    const xmargin = 16;
    const bbox = UI.planeplot.getBoundingClientRect();
    const pixr = [xl/(bbox.width-xmargin*2), yl/(bbox.height)]; // pixel ratio
    const limPad = [pixr[0]*20, pixr[1]*10]; // visible limits inward padding
    const quadCmap = {'LOW': '#8f3c3c', 'HIGH': '#3c8543'};
    const quadPad = [pixr[0]*7, pixr[1]*3];
    const round1p = v => Math.round(v*10)/10;
    const borderElem = UI.plane.querySelector('.border');
    borderElem.style.width = (bbox.width-xmargin*2) + 'px';
    borderElem.style.height = bbox.height + 'px';
    borderElem.style.marginLeft = xmargin + 'px';

    const lines = Object.entries(name2entries).map(([name, entries]) => {
        const hero = heroes[name];
        const color = CMAP[name] || hero.color;
        const points = conf.facetValues.map(facetValue => {
            if (!conf.facetValuesSelected.has(facetValue)) return;
            const selected = entries.filter(e => (
                e[conf.facet] === facetValue && (e.tier === conf.lastTier || conf.facet === 'tier'))
            );
            if (selected.length > 1) throw Error('unexpected multiple entries after filter');
            const entry = selected[0];
            if (!entry || entry.winrate === -1 || entry.pickrate === -1) return;
            return {
                x: entry.winrate,
                y: entry.pickrate / expectedBase.pr[hero.role],
                pr: entry.pickrate,
                fc: conf.facetCmap[facetValue],
                fname: facetValue,
            };
        }).filter(p => p);
        const mainIdx = points.map(p => p.fname).indexOf(conf.sortFacetValue);
        const clamped = [
            clamp(points[mainIdx]?.x, xrange[0]+limPad[0], xrange[1]-limPad[0]),
            clamp(points[mainIdx]?.y, yrange[0]+limPad[1], yrange[1]-limPad[1])
        ];
        return {
            x: pluck(points, 'x'), y: pluck(points, 'y'),
            xc: clamped[0], yc: clamped[1],
            xt: clamped[0], yt: clamped[1],
            name: hero.name,
            color: color,
            colorFade: color + '66',
            colorFacet: pluck(points, 'fc'),
            symbol: 'circle',
            mainIdx: mainIdx,
            size: points.map((_, i) => (i === mainIdx) ? 6 : 4),
            hover: points.map(p =>
                `<extra><b style='color:#666'>${hero.name}</b> <b style='color:${p.fc}'>${ALT_NAMES[p.fname] || p.fname}</b></extra>` +
                `Wr <b>${p.x}</b>%  Pr <b>${p.pr}</b>%(${round1p(p.y)} Avg.)`
            ),
        };
    });

    // Algo to find better annotation positions:
    // repell over y, snap to above or below marker, repell again
    function repell(n) {
        Array.from({length: n}).forEach(_ => {lines.forEach(a => {lines.forEach(b => {
            if (b === a || a.xt == null || b.xt == null || a.y > yrange[1]) return;
            let [x1, x2, y1, y2] = [a.xt/pixr[0], b.xt/pixr[0], a.yt/pixr[1], b.yt/pixr[1]];
            if (Math.abs((x1 - x2)) > 40 || Math.abs((y1 - y2)) > 20) return;
            const dir = Math.sign(y1 - y2) || 1;
            a.yt += pixr[1]*3*dir;
            b.yt += pixr[1]*3*-dir;
        }); }); });
    }
    repell(5);
    lines.forEach(l => { l.yt = l.yc + (pixr[1]*13*(l.yt - l.yc > 0 ? 1 : -1)); });
    repell(5);

    Plotly.react(UI.planeplot, lines.flatMap(l => {
        let traces = [{
            // Solid line from text to point (when out of bounds)
            x: [l.x[l.mainIdx], l.xc], y: [l.y[l.mainIdx], l.yc],
            mode: 'lines',
            name: l.name,
            line: {simplify: false},
            hoverinfo: 'skip',
            marker: {color: l.color, size: 7, symbol: l.symbol, line: {width: 0}, opacity: [1, 0]},
        }, {
            // Main line: facet connection line and dots
            x: l.x, y: l.y,
            mode: 'lines+markers',
            line: {color: l.colorFade, dash: 'solid', simplify: false},
            hovertemplate: l.hover,
            name: l.name,
            hoverlabel: {bgcolor: 'white', font: {color: '#666'}, bordercolor: l.colorFade},
            marker: {
                size: l.size, symbol: l.symbol, opacity: 1,
                color: conf.planeMarkerColor ?  l.colorFacet : l.color,
                line: {width: conf.planeMarkerColor ? 1.5 : 0, color: l.colorFade}
            },
        }, {
            // Text annotation
            x: [l.xt], y: [l.yt],
            // x: [l.xt], y: [l.yc-pixr[1]*13],
            mode: 'text',
            text: l.name,
            zorder: 10,
            hoverinfo: 'skip',
            textfont: {color: l.color, size: 12, weight: 600}
        }];
        if (l.mainIdx === -1) traces = [{}, traces[1], {}];
        return traces;
    }), {
        margin: {l: xmargin, r: xmargin, t: 0, b: 0},
        showlegend: false,
        plot_bgcolor: '#0000',
        paper_bgcolor: '#0000',
        dragmode: 'pan',
        yaxis: {
            range: yrange,
            zeroline: false,
            showgrid: false,
            ticklen: 5,
            tickcolor: '#0000',
            tickvals: [1, 2, 3],
            ticktext: ['Role Avg.<br><b>PICKRATE</b>', '2X Avg.', '3X Avg.'],
            tickfont: {size: 12, color: 'rgba(0,0,0,0.6)'},
        },
        xaxis: {
            range: xrange,
            showgrid: false,
            zeroline: false,
            ticklen: 1,
            tickcolor: '#0000',
            tickvals: Array.from({length: 21}).map((_, i) => i*5),
            ticktext: Array.from({length: 21}).map((_, i) => `${i*5}%` + (i === 10 ? '<br><b>WINRATE</b>' : '')),
            tickfont: {size: 12, color: 'rgba(0,0,0,0.6)'},
        },
        shapes: [
        ...[
            [[0, 100, 1, 1], 1, 1.5, 'dot'],
            [[50, 50, -100, 100], 1, 1.5, 'dot'],
            [[50, 50, -100, 100], 1, 1.5, 'dot'],
            [[0, 100, 2, 2], .2, .5, 'dash'],
            [[0, 100, 3, 3], .2, .5, 'dash'],
            [[45, 45, -100, 100], .2, .5, 'dash'],
            [[55, 55, -100, 100], .2, .5, 'dash'],
            [[-100, 100, 0, 0], .2, .5, 'solid'],
        ].map(([c, o, w, dash]) => ({
            type: 'line', x0: c[0], x1: c[1], y0: c[2], y1: c[3], opacity: o,
            line: {color: 'black', width: w, dash: dash}, layer: 'between',
        }))],
        annotations: [{
            xref: 'x', yref: 'y', x: xrange[0]+xl/2+quadPad[0], y: yrange[0]+quadPad[1],
            xanchor: 'left', yanchor: 'bottom',
            text: `Rank: <span  style="background-color: yellow; padding: 2px;">${ALT_NAMES[conf.lastTier] || conf.lastTier}</span>`,
            opacity: conf.facet !== 'tier' ? .3 : 0, showarrow: false, font: {size: 11, weight: 600},
        },
        ...[
            [xrange[0]+quadPad[0], yrange[0]+quadPad[1], 'LOW', 'LOW', 'left', 'bottom'],
            [xrange[0]+quadPad[0], yrange[1]-quadPad[1], 'LOW', 'HIGH', 'left', 'top'],
            [xrange[1]-quadPad[0], yrange[0]+quadPad[1], 'HIGH', 'LOW', 'right', 'bottom'],
            [xrange[1]-quadPad[0], yrange[1]-quadPad[1], 'HIGH', 'HIGH', 'right', 'top'],
        ].map(a => ({
            xref: 'x', yref: 'y', x: a[0], y: a[1], xanchor: a[4], yanchor: a[5], text:
                `<span style="color:${quadCmap[a[2]]}">${a[2]} WIN</span>  <span style="color:${quadCmap[a[3]]}">${a[3]} PICK</span>`,
            opacity: .3, showarrow: false, font: {size: 12, weight: 600},
        }))],
    }, {displayModeBar: false, doubleClick: 'reset'});

    if (!UI.planeplot._hoverBound) {
        UI.planeplot._hoverBound = true;
        const fn = data => {
            const p = data.points[0];
            Plotly.Fx.hover(UI.planeplot, p.data.x.map((_, i) => ({curveNumber: p.curveNumber, pointNumber: i})));
        };
        UI.planeplot.on('plotly_hover', fn);
        UI.planeplot.on('plotly_click', fn);
    }
}


function renderStackedPRBar(name2entries, conf) {
    if (conf.filterRole === 'all' || !conf.facetValuesSelected.size) {
        UI.stackedPRBar.innerHTML = '';
        return;
    }
    let entries = Object.entries(name2entries).map(([name, entries]) => {
        entries = entries.filter(e => (
            e[conf.facet] === conf.sortFacetValue && (e.tier === conf.lastTier || conf.facet === 'tier'))
        );
        if (entries.length > 1) throw new Error('unexpected multiple entries after filter');
        if (!entries.length) return;
        const e = entries[0];
        const hero = heroes[name];
        return {
            pr: e.pickrate,
            pct: e.pickrate / (hero.role === 'tank' ? 100 : 200),
            avg: Math.round(e.pickrate / expectedBase.pr[hero.role] * 10)/10,
            name: hero.name,
            color: hero.color,
        };
    });
    entries = sortBy(entries, e => -e.pr);
    const fcolor = conf.facetCmap[conf.sortFacetValue];
    const fname = ALT_NAMES[conf.sortFacetValue] || conf.sortFacetValue;
    UI.stackedPRBar.innerHTML = entries.map((e, i) =>
        `<div class='bar' style='height:${e.pct*100}%;background-color:${e.color}88;'>
            <div class='tooltip'>
                <b>${e.name} <span style='color:${fcolor}'>${fname}</span></b>
                <span class='extra' style='box-shadow:0 0 0 1px ${e.color}88 inset'>
                    Pr <b>${e.pr}</b>%(${e.avg} Avg.)
                </span>
            </div>
        </div>`
    ).join('');
}


function computeRegionMeans(entries) {
    const staticFields = ['hero', 'mode', 'map', 'input', 'tier'];
    const computeFor = ['winrate', 'pickrate'];
    const calcMean = (objs, k) => {
        const vals = objs.map(o => o[k]).filter(v => v !== -1);
        if (!vals.length) return -1;
        return Math.round(vals.reduce(sum, 0) / vals.length * 10) / 10;
    };
    const groups = {};
    entries.forEach(e => {
        const key = staticFields.map(k => e[k]).join(',');
        if (!groups[key]) groups[key] = [Object.fromEntries(staticFields.map(k => [k, e[k]]))];
        groups[key].push(e);
    });
    return Object.values(groups).map(group => {
        const copy = group.shift();
        return {
            region: 'mean',
            ...copy,
            ...Object.fromEntries(computeFor.map(k => [k, calcMean(group, k)])),
        }
    });
}


class ConfHandler {
    constructor() {
        this._fillFacetOptions();
        this.elems = [...document.querySelectorAll('.conf *[id]')];
        this.elems.forEach(el => el.addEventListener('change', _ => this.sync()));
        this._conf = {};
        this._defaultConf = {};
        this._sortElems = {
            'region': UI.sortingRegion,
            'input': UI.sortingPlatform,
            'mode': UI.sortingGameMode,
            'tier': UI.sortingTier,
        };
        this._firstSync = true;
        this.sync(false);
        delete this._firstSync;
    }
    sync(doRender = true) {
        const conf = this._conf;
        let oldConf = {...conf};
        this.elems.forEach(el => conf[el.id] = inputElemValue(el));
        if (this._firstSync) {
            this._defaultConf = oldConf = {...conf};
            this._loadUrlHash();
        }
        this._applyRules(oldConf);
        this._setDisabled();
        this._applyEffects(oldConf);
        this._setUrlHash();

        this.lastTier = this.lastTier || 'All';
        if (conf.sortingMode === 'all') this.lastTier = 'All';
        if (conf.sortingMode.includes('tier-')) this.lastTier = conf.sortingMode.slice(5);

        this.regionMeanView = (conf.filterRegion === 'mean' && conf.facet === 'region');

        if (doRender) render();
    }
    _fillFacetOptions() {
        const capit = v => v.charAt(0).toUpperCase() + v.slice(1);
        const addTitle = vals => vals.map(v => [v, ALT_NAMES[v] || v]);
        const toOptions = vals => vals.map(([v, t]) => `<option value='${v}'>${t}</option>`).join('\n');
        const toChboxes = vals => vals.map(([v, t]) => `<label><input type='checkbox' value='${v}' checked/>${t}</label>`).join('\n');
        [
            ['option.fillRegions', toOptions(addTitle(REGIONS))],
            ['option.fillPlatforms', toOptions(addTitle(PLATFORMS))],
            ['option.fillModes', toOptions(addTitle(GAMEMODES))],
            ['option.fillRoles', toOptions(ROLES.map(v => [v, capit(v)]))],
            ['#sortingMode option.fillTiers', toOptions(TIERS.map(v => [`tier-${v}`, `:${ALT_NAMES[v] || v}`]))],
            ['#sortingTier option.fillTiers', toOptions(addTitle(['All', ...TIERS]))],
            ['checkbox.fillRegions', toChboxes(addTitle(REGIONS))],
            ['checkbox.fillPlatforms', toChboxes(addTitle(PLATFORMS))],
            ['checkbox.fillModes', toChboxes(addTitle(GAMEMODES))],
            ['checkbox.fillTiers', toChboxes(addTitle(['All', ...TIERS]))],
        ].forEach(([s, html]) => document.querySelectorAll(s).forEach(e => e.outerHTML = html));
        UI.sortingRegion.value = REGIONS[0];
        inputElemValue(UI.selectedRegions, ['Americas', 'Asia']);
        inputElemValue(UI.selectedTiers, ['Gold', 'Diamond', 'Master']);
    }
    _setUrlHash() {
        const simple = (v) => v instanceof Set ? [...v].sort().join(',') : v;
        let kvs = Object.entries(this._conf).map(([k, v]) => [k, simple(v)]).filter(([k, v]) =>
            v !== simple(this._defaultConf[k]) && !UI[k]?.disabled
        );
        const order = this.elems.map(e => e.id);
        kvs = sortBy(kvs, kv => order.indexOf(kv[0]));
        history.replaceState(null, '', '#' + kvs.map(kv => kv.join('=')).join('&'));
        // remove lone trailing #
        if (!location.hash) history.replaceState(null, '', location.pathname + location.search);
    }
    _loadUrlHash() {
        (new URLSearchParams(location.hash.slice(1))).forEach((v, k) => {
            if (!UI[k]) return;
            if (UI[k].classList.contains('checkboxes')) v = new Set(v.split(','));
            if (UI[k].type === 'checkbox') v = {'true': true, 'false': false}[v];
            this._conf[k] = inputElemValue(UI[k], v);
        });
    }
    _applyEffects(oldConf) {
        // effects that won't mutate the confs
        const conf = this._conf;

        Object.keys(oldConf).forEach(key => {
            if (oldConf[key] === conf[key]) return;
            if (key === 'cnExtra')
                UI.selectColumn.value = conf.cnExtra ? 'kd' : 'wr';
            if (this._firstSync) return;
            if (key === 'chinaOn' && conf.chinaOn)
                flash(UI.cnExtra.parentElement, 'flash');
            if (key === 'sortingMode' || this.getFacets(conf).sortFacetValue !== this.getFacets(oldConf).sortFacetValue)
                flash(document.querySelector('.col-title.active span'), 'flash');
        });

        UI.main.classList.remove([...UI.main.classList].filter(c => c.startsWith('viewmode-')));
        UI.main.classList.add('viewmode-' + conf.viewMode);

        // reflect sort column
        document.querySelector('.col-titles').classList.toggle('inv', conf.sortingReverse);
        document.querySelectorAll('.col-title').forEach(el => {
            el.classList.toggle('active', el.dataset.sort === conf.sortingColumn);
        });

        document.body.classList.toggle('show-cn-extra', conf.cnExtra);
        mobileSelectColumns();
        toggleWarnings(this.frozenConf());
    }
    _applyRules(oldConf) {
        const alter = (k, v) => { this._conf[k] = v; inputElemValue(UI[k], v); };
        const rules = [
            [
            // [condition(conf, oldConf), effect()], ...
            // Rules that compare with oldConf are generally "soft" rules.
            conf => conf.facet !== 'region' && conf.filterRegion === 'all',
            conf => alter('filterRegion', REGIONS[0])
            ], [
            conf => !conf.chinaOn && conf.sortingRegion === 'China',
            conf => alter('sortingRegion', REGIONS[0])
            ], [
            conf => !conf.chinaOn && conf.filterRegion === 'China',
            conf => alter('filterRegion', 'all')
            ], [
            conf => !conf.chinaOn && conf.selectedRegions.has('China'),
            conf => {conf.selectedRegions.delete('China'); alter('selectedRegions', conf.selectedRegions)}
            ], [
            (conf, last) => last.cnExtra !== conf.cnExtra && conf.viewMode === 'plane' && conf.cnExtra,
            conf => alert(WARNINGS.planekda)
            ], [
            conf => conf.viewMode === 'plane' && conf.cnExtra,
            conf => alter('cnExtra', false)
            ], [
            conf => !conf.chinaOn && conf.cnExtra,
            conf => alter('cnExtra', false)
            ], [
            conf => !['all', 'mean'].includes(conf.filterRegion) && conf.sortingRegion !== conf.filterRegion,
            conf => alter('sortingRegion', conf.filterRegion)
            ], [
            conf => conf.facet !== 'region' && conf.filterRegion === 'mean' && conf.sortingRegion !== conf.filterRegion,
            conf => alter('sortingRegion', conf.filterRegion)
            ], [
            conf => conf.cnExtra && conf.filterRegion !== 'China',
            conf => alter('filterRegion', 'China')
            ], [
            conf => conf.viewMode === 'bars' && conf.sortingMode === 'b-m-delta',
            conf => alter('sortingMode', 'all')
            ], [
            conf => conf.viewMode === 'plane' && conf.sortingMode !== 'all' && !conf.sortingMode.startsWith('tier-'),
            conf => alter('sortingMode', 'all')
            ], [
            conf => conf.viewMode === 'plane' && conf.facet === 'region' && conf.filterRegion !== 'all',
            conf => alter('filterRegion', 'all')
            ], [
            conf => conf.viewMode !== 'plane' && conf.facet === 'tier',
            conf => alter('facet', 'region')
            ], [
            conf => {
                const fasets = this.getFacets(conf);
                const selected = fasets.facetValuesSelected;
                return conf.viewMode === 'plane' && selected.size && !selected.has(fasets.sortFacetValue)
            },
            conf => alter(this._sortElems[conf.facet].id, [...this.getFacets(conf).facetValuesSelected][0])
            ], [
            (conf, last) => last.filterRegion !== conf.filterRegion && conf.filterRegion === 'mean',
            conf => alter('sortingRegion', conf.filterRegion)
            ], [
            (conf, last) => last.viewMode !== conf.viewMode && conf.viewMode === 'plane' && conf.filterRole === 'all',
            conf => alter('filterRole', ROLES[0])
            ], [
            (conf, last) => last.facet !== conf.facet && conf.facet === 'region',
            conf => alter('filterRegion', 'all')
            ]
        ];
        this._appliedRules = [];
        let i = 0, anyChanges;
        do {
            if (i > 10) throw Error('broken conf state');
            i++;
            anyChanges = false;
            for (const rule of rules) {
                if (rule[0](this._conf, oldConf)) {
                    rule[1](this._conf);
                    anyChanges = true;
                    this._appliedRules.push(i + ') ' + rule[0].toString());
                }
            }
            oldConf = {...this._conf};
        } while (anyChanges);
    }
    _setDisabled() {
        const conf = this._conf;
        const facets = this.getFacets();
        const cnElems = document.querySelectorAll('option[value="China"], input[value="China"]');
        cnElems.forEach(el => el.disabled = false);
        this.elems.forEach(el => {
            el.disabled = false;
            el.querySelectorAll('option').forEach(el => el.disabled = false);
        });

        Object.entries({
            'region': [UI.sortingRegion, UI.selectedRegions],
            'input': [UI.sortingPlatform, UI.selectedPlatforms],
            'mode': [UI.sortingGameMode, UI.selectedGameModes],
            'tier': [UI.sortingTier, UI.selectedTiers],
        }).forEach(([f, elems]) => {
            elems.forEach(el => {
                el.classList.toggle('hidden', conf.facet !== f);
                el.disabled = conf.facet !== f;
                if (el.id.startsWith('sorting') && conf.sortingMode === 'facets-spread')
                    el.disabled = true;
                if (el.id.startsWith('selected') && conf.viewMode !== 'plane')
                    el.disabled = true;
            });
        });

        if (!['all', 'mean'].includes(conf.filterRegion))
            UI.sortingRegion.disabled = true;
        if (conf.facet === 'input')
            UI.filterPlatform.disabled = true;
        if (conf.facet === 'region' && conf.viewMode === 'plane')
            UI.filterRegion.disabled = true;
        UI.facet.querySelector('option[value=tier]').disabled = conf.viewMode !== 'plane';
        UI.filterRegion.querySelector('option[value=all]').disabled = (
            conf.facet !== 'region'
        );
        UI.sortingMode.querySelector('option[value=b-m-delta]').disabled = (
            conf.viewMode === 'bars'
        );
        UI.sortingMode.disabled = conf.viewMode === 'plane' && conf.facet === 'tier';
        if (conf.viewMode === 'plane') {
            [...this._sortElems[conf.facet].children].forEach(
                el => el.disabled = !facets.facetValuesSelected.has(el.value)
            );
            [...UI.sortingMode.children].forEach(
                el => el.disabled = el.value !== 'all' && !el.value.startsWith('tier-')
            );
        }
        if (!conf.chinaOn)
            cnElems.forEach(el => el.disabled = true);
        UI.cnExtra.disabled = !conf.chinaOn;
        if (conf.cnExtra)
            UI.filterRegion.disabled = true;
    }
    getFacets(conf) {
        conf = conf || this._conf;
        let facetColors, facets = {};
        if (conf.facet === 'region') {
            facets.facetValues = REGIONS;
            facetColors = [...REGION_COLORS, CMAP.mean];
            if (conf.filterRegion === 'mean' || conf.viewMode === 'plane')
                facets.facetValues = [...REGIONS, 'mean'];
        } else if (conf.facet === 'input') {
            facets.facetValues = PLATFORMS;
            facetColors = [CMAP[conf.filterRegion], EXTRA_COLORS.Console];
        } else if (conf.facet === 'mode') {
            facets.facetValues = GAMEMODES;
            facetColors = [CMAP[conf.filterRegion], EXTRA_COLORS.QP];
        } else if (conf.facet === 'tier') {
            facets.facetValues = ['All', ...TIERS];
            facetColors = [EXTRA_COLORS.allTiers, ...TIER_COLORS];
        }
        facets.facetValuesSelected = {
            'mode': conf.selectedGameModes,
            'region': conf.selectedRegions,
            'input': conf.selectedPlatforms,
            'tier': conf.selectedTiers,
        }[conf.facet];
        facets.sortFacetValue = this._sortElems[conf.facet].value;
        facets.facetCmap = Object.fromEntries(facets.facetValues.map((v, i) => [v, facetColors[i]]));
        return facets;
    }
    frozenConf() {
        return {
            ...this._conf,
            ...this.getFacets(),
            regionMeanView: this.regionMeanView,
            lastTier: this.lastTier,
        }
    }
}


function setupEventHandlers() {
    UI.selectColumn.addEventListener('change', mobileSelectColumns);
    const infoPopup = document.querySelector('.info-popup');
    UI.infoPopupClose.addEventListener('click',
        () => infoPopup.classList.add('hidden')
    );
    document.addEventListener('keydown', e => pressedKeys.add(e.key));
    document.addEventListener('keyup', e => pressedKeys.delete(e.key));
    document.addEventListener('click', function(e) {
        if (!e.target.classList.contains('trigger-info') && !infoPopup.contains(e.target))
            infoPopup.classList.add('hidden');
        else if (e.target.classList.contains('trigger-info'))
            infoPopup.classList.remove('hidden');
        // for phones: unhover/unfocus plot if clicked off it
        document.querySelectorAll('.plot.js-plotly-plot').forEach(plot => {
            if (e.target.classList.contains('stub') && e.target.parentElement.contains(plot)) return;
            if (plot.contains(e.target)) return;
            Plotly.Fx.unhover(plot);
            mobileFocusPlot(plot.parentElement, false);
        });
    });
    document.querySelectorAll('.col-title span').forEach(
        elem => elem.addEventListener('click', titleClickSort)
    );
    document.querySelectorAll('.info-popup .spoiler .clicker').forEach(
        elem => elem.addEventListener('click', () => elem.parentElement.classList.toggle('open'))
    );
}


function toggleWarnings(conf) {
    const html = [
        [WARNINGS.cn, conf.chinaOn],
        [WARNINGS.avg, (
            conf.filterRegion === 'mean' ||
            conf.sortFacetValue === 'mean' ||
            conf.facetValuesSelected.has('mean')
        )],
    ].map(
        ([text, cond]) => cond ? `<span class="trigger-info">${text}</span>` : null
    ).filter(t => t).join(' ┊ ');
    const warnElem = document.querySelector('.warnings')
    warnElem.classList.toggle('hidden', !html);
    warnElem.innerHTML = html;
}


function setupColorTips() {
    const vals = [...REGIONS, 'Console'];
    UI.colorTips.innerHTML = vals.map(v => {
        return `<span style='color:${CMAP[v]}'>${v}</span>`
    }).join(', ');
}


function loadArchiveInfo(jsonpSrc) {
    loadJonp(jsonpSrc);
}


function receiveArchiveInfo(html) {
    UI.archiveInfo.style.display = '';
    UI.archiveInfo.querySelector('ul').innerHTML = html;
}


function mobileSelectColumns() {
    UI.main.classList.remove([...UI.main.classList].filter(c => c.startsWith('mobile-show-')));
    UI.main.classList.add('mobile-show-' + UI.selectColumn.value);
}


function titleClickSort(evt) {
    const elem = evt.target.parentElement;
    if (elem.classList.contains('active'))
        UI.sortingReverse.checked = !UI.sortingReverse.checked;
    else {
        UI.sortingColumn.value = elem.dataset.sort;
        UI.sortingReverse.checked = true;
    }
    confHandler.sync();
}


function plotToggleZoom(plot) {
    const default_ = plot._defaultYrange;
    const cur = plot._fullLayout.yaxis.range;
    const ctrl = pressedKeys.has('Control');
    if (default_[0] !== cur[0] && default_[1] !== cur[1] && !ctrl) {
        Plotly.relayout(plot, {'yaxis.range': default_.slice()});
        flash(plot.parentElement, 'blink', 200);
        return;
    }
    let traces = plot._fullData;
    const conf = confHandler.frozenConf();
    if (conf.filterRegion === 'mean' && conf.facet === 'region')
        // in mean view we only show regional traces for faint reference so ignore them
        traces = [traces.at(-1)];
    const ys = traces.flatMap(trace => trace.y).filter(v => v != null);
    let a = Math.min(...ys), b = Math.max(...ys);
    if (ctrl) a = 0;
    const margin = (b - a)*.1;
    Plotly.relayout(plot, {'yaxis.range': [a-margin, b+margin]});
}


function mobileFocusPlot(plotParent, focus = true, evt = null) {
    if (focus && !plotParent.classList.contains('mobile-focused')) {
        // the stub will be hidden, now propagate hover into the plot itself
        const plot = plotParent.querySelector('.plot');
        const rect = plotParent.getBoundingClientRect();
        Plotly.Fx.hover(plot, {
            xpx: evt.clientX - rect.left - plot._fullLayout.margin.l,
            ypx: evt.clientY - rect.top,
        });
    }
    plotParent.classList.toggle('mobile-focused', focus);
}


function inputElemValue(elem, set) {
    if (elem.classList.contains('checkboxes')) {
        const current = () => new Set([...elem.querySelectorAll('input[type=checkbox]:checked')].map(e => e.value));
        if (set == null) return current();
        set = new Set(set)
        elem.querySelectorAll('input[type=checkbox]').forEach(e => e.checked = set.has(e.value));
        return current();
    }
    const attr = elem.type === 'checkbox' ? 'checked' : 'value';
    if (set != null) elem[attr] = set;
    return elem[attr];
}


function sortBy(values, key) {
    const decorated = values.map(v => [v, key(v)]);
    decorated.sort((a, b) => a[1] - b[1]);
    return decorated.map(v => v[0]);
}


function pluck(objArr, key) {
    return objArr.map(e => e[key]);
}


function calcMAD(bins) {
    const totPoints = bins.flatMap(vals => vals.length).reduce(sum, 0);
    return bins.map(vals => {
        if (vals.length <= 1) return 0;
        const mean = vals.reduce(sum, 0) / vals.length;
        return vals.map(v => Math.abs(v-mean)).reduce(sum, 0)
    }).reduce(sum, 0) / totPoints;
}


function flash(elem, className, timeout) {
    elem.classList.remove(className);
    setTimeout(() => elem.classList.add(className), 0);
    setTimeout(() => elem.classList.remove(className), timeout || 1000);
}


function sum(a, b) {return a+b;}


function clamp(v, a, b) {
    if (a != null && v < a)
        return a;
    if (b != null && v > b)
        return b;
    return v;
}


setup();

</script>
</body>
</html>
